<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coding on 白汤四物</title><link>https://www.fournoas.com/categories/coding/</link><description>Recent content in Coding on 白汤四物</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 05 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.fournoas.com/categories/coding/index.xml" rel="self" type="application/rss+xml"/><item><title>速通 SOCKS5 代理协议</title><link>https://www.fournoas.com/posts/socks5-proxy-protocol-quick-start/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/socks5-proxy-protocol-quick-start/</guid><description>SOCKS5 是最常见的代理服务协议，服务通常使用 1080 端口，支持代理 TCP/UDP 网络协议。协议由 RFC 1928 定义，也可以阅读非官方翻译的中文版。本文主要用于快速入门，省略了协议中不常用的部分。文中提供了协议的部分 Python 代码实现。 连接 SOCKS5 代理服务的 Python 代码如下： import ipaddress import socket import struct proxy_host = 'localhost' proxy_port= 1080 proxy_username = '' proxy_password = '' proxy_version = 0x05 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((proxy_host, proxy_port)) 协商阶段</description></item><item><title>asyncio.DatagramProtocol 收到错误后停止响应</title><link>https://www.fournoas.com/posts/asyncio.DatagramProtocol-stop-responding-when-an-error-is-received/</link><pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/asyncio.DatagramProtocol-stop-responding-when-an-error-is-received/</guid><description>Python 官方文档提供了一个使用 asyncio 创建 UDP Echo Server 的示例，代码如下： import asyncio class EchoServerProtocol: def connection_made(self, transport): self.transport = transport def datagram_received(self, data, addr): message = data.decode() print('Received %r from %s' % (message, addr)) print('Send %r to %s' % (message, addr)) self.transport.sendto(data, addr) async def main(): print(&amp;quot;Starting UDP server&amp;quot;) # Get a reference to the event loop as we plan to use # low-level APIs. loop = asyncio.get_running_loop() # One protocol instance will be created to serve all # client requests. transport, protocol = await loop.create_datagram_endpoint( lambda: EchoServerProtocol(), local_addr=('127.0.0.1', 9999)) try: await asyncio.sleep(3600) # Serve for 1 hour. finally: transport.close() asyncio.run(main()) 然而，一旦收到运行时错误，该 UDP Server 便会失去响应</description></item><item><title>Python asyncio 模块实现简单异步 https 请求</title><link>https://www.fournoas.com/posts/python-asyncio-module-implements-simple-asynchronous-https-requests/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-asyncio-module-implements-simple-asynchronous-https-requests/</guid><description>网上关于 asyncio 实现异步 https 请求的代码几乎都是基于Python 第三方库 aiohttp 的，而我仅需要一个无第三方依赖的、能一键运行的简单 Python 脚本。翻了翻官方文档，也没有什么值得参考的 sample 代码。无奈只能自己动手撸一个。 以下示例代码的作用是，请求百度首页，并将响应打印出来。支持 Python 3.7 及以上的版本。 版本一 使用 loop.create_connection() 从</description></item><item><title>Python 信号处理在不同平台上的差异</title><link>https://www.fournoas.com/posts/handling-signal-in-python-on-different-platforms/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/handling-signal-in-python-on-different-platforms/</guid><description>在前文《为何 Windows 下无法用 Ctrl+C 终止 Python 进程》中，虽然解释了产生该现象的原因，但却没有解释为何同样的代码在 Linux 下就可以用 Ctrl+C 来中止。究其原因，是由于在操作系统层面，Linux 和 Windows 对 SIGINT 的信号处理方式不同所导致的。 Python 的底层实现原理 Python 将操作系统或 C 标准库提供的信号处理器称作 Low-level signal handler，Pyt</description></item><item><title>Python 的 signal 处理与 print() 的 reentrant call 运行时错误</title><link>https://www.fournoas.com/posts/python-signal-handlers-and-reentrant-call-runtime-error-of-print-function/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-signal-handlers-and-reentrant-call-runtime-error-of-print-function/</guid><description>在前文《为何 Windows 下无法用 Ctrl+C 终止 Python 进程》中，讲解了 Python 信号处理的基本原理。当时为了撰写文章而编写了一些测试代码，在运行某例测试代码时，发生了奇怪的 reentrant call 运行时错误。代码如下： import signal signal.signal(signal.SIGINT, lambda signum, frame: print('test')) while True: print('test') 在程序运行中按下 Ctrl+C，程序抛出 RuntimeError 异常。完整错误信息如下： Traceback (most recent call last): File &amp;quot;test.py&amp;quot;, line 4, in &amp;lt;module&amp;gt; while True: print('test') ^^^^^^^^^^^^^</description></item><item><title>为何 Windows 下无法用 Ctrl+C 终止 Python 进程</title><link>https://www.fournoas.com/posts/why-does-ctrl-c-not-kill-python-process-in-windows-console/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/why-does-ctrl-c-not-kill-python-process-in-windows-console/</guid><description>在 Windows 命令行中按下 Ctrl+C 或者 Ctrl+Break 可以结束当前正在执行的命令。通常情况下，这个方法同样适用于 Python 的控制台进程。特别地，Python 内置了一个 KeyboardInterrupt 异常专门用于捕获按下 Ctrl+C 而触发的程序退出： try: while True: print('running...') except KeyboardInterrupt: print('keyboard interrupt received') # 退出前清理现场，释放资源 Python 触发 KeyboardInterrupt 异常的底层实现原理依赖于 signal 机制1。使用信号处理器也可以捕获</description></item><item><title>一道初中奥数题的蒙特卡洛解法</title><link>https://www.fournoas.com/posts/monte-carlo-simulation-of-a-middle-school-math-olympiad-problem/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/monte-carlo-simulation-of-a-middle-school-math-olympiad-problem/</guid><description>四只鸭子在一个圆形水池中随机游动。某一时刻，四只鸭子在同一半圆内的概率是多少？ 这个问题必须隐含一个前提：当水池被分为两半后，任意一只鸭子，要么属于这一边，要么属于另一边，不存在同时属于两边或不属于任何一边的情况。可以把鸭子视作质点，如果鸭子正好落在分割线上，则认为此鸭子属于顺时针</description></item><item><title>JavaScript 的原型继承</title><link>https://www.fournoas.com/posts/javascript-prototypal-inheritance/</link><pubDate>Sun, 09 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/javascript-prototypal-inheritance/</guid><description>一张经常被使用的关系图 JavaScript 中的每个对象都有一个 [[Prototype]] 的内部属性，该属性指向的对象就是当前对象的原型。每个原型对象也有自己的原型，依次向上遍历形成原型链。当我们访问一个对象的属性或者方法时，如果在当前对象中没有找到该属性或者方法，会通过原型链依次从原型对象中查找，从而实现对象继承的功能。</description></item><item><title>单元测试中的 Dummy、Stub、Spy、Fake 和 Mock</title><link>https://www.fournoas.com/posts/dummy-stub-spy-fake-and-mock-in-unit-test/</link><pubDate>Tue, 27 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/dummy-stub-spy-fake-and-mock-in-unit-test/</guid><description>单元测试用来验证一个单元（模块、函数或类）的工作是否正常，测试过程通常需要其他单元进行配合。这种情况下，我们引入测试替身（Test doubles）来替代测试单元的外部依赖，使得测试单元能够顺利运行。这些测试替身分为五种，分别是： Dummy Stub Spy Fake Mock Dummy 或称为 Dummy Object。指在测试中用来传递</description></item><item><title>Python 的 MRO 和 C3 线性化</title><link>https://www.fournoas.com/posts/python-MRO-and-C3-linearization/</link><pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-MRO-and-C3-linearization/</guid><description>MRO，即 Method Resolution Order、方法解析顺序，是 Python 对象调用父类方法时的遍历顺序。由于 Python 支持多重继承，类的继承关系可视作一个有向无环图，方法解析顺序就相当于拓扑排序——将图中节点线性排列。自 Python 2.3 起，新式类通过 C3 线性化算法来计算 MRO。 之所以被称作 C3，是因为算法符合如下三个特性（Cons</description></item><item><title>Unikernel 和 Library OS</title><link>https://www.fournoas.com/posts/unikernel-and-library-os/</link><pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/unikernel-and-library-os/</guid><description>Unikernel，中文一般翻译为单一内核。是专门为了运行在虚拟机上而打造的系统。维基百科上的解释是： A unikernel is a specialised, single address space machine image constructed by using library operating systems. A developer selects, from a modular stack, the minimal set of libraries which correspond to the OS constructs required for the application to run. These libraries are then compiled with the application and configuration code to build sealed, fixed-purpose images (unikernels) which run directly on a hypervisor or hardware without an intervening OS such as Linux or Windows. 在解释什么是 Unikernel 前，先来了解一下</description></item><item><title>为网页添加侧边栏目录导航</title><link>https://www.fournoas.com/posts/adding-a-table-of-contents-to-the-sidebar-in-webpages/</link><pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/adding-a-table-of-contents-to-the-sidebar-in-webpages/</guid><description>起因 一直很反感那些花里胡哨的博客模板，所以为这个网站选择了一套非常简约的主题，并在此基础上简单地修改。主要是将默认的衬线字体改成了非衬线字体，增加了顶部的导航栏等。 主题默认的章节目录和正文是顺序堆叠（stacklayout）的。然而，在实际使用过程中发现，当文章内容很长时，如果没</description></item><item><title>特殊的服务器环境引发的 Laravel 框架异常</title><link>https://www.fournoas.com/posts/a-laravel-exception-caused-by-special-server-environment/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/a-laravel-exception-caused-by-special-server-environment/</guid><description>一个使用 Laravel 框架的项目，在某次更新生产环境代码后报了奇怪的错误。而代码在开发环境和测试环境运行都是正常的。由于无法接触到生产环境，只能通过 PHP 引擎的源代码来猜测导致错误的原因</description></item><item><title>JavaScript 异步可迭代定时器</title><link>https://www.fournoas.com/posts/async-iterable-timer-in-javascript/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/async-iterable-timer-in-javascript/</guid><description>ES8（ES2017）引入了 async 函数和 await 关键字。await 关键字可用于 async 修饰的异步函数或者一个 Promise 对象，而异步函数本质上也就是一个返回 Promise 对象的语法糖。 ES9（ES2018） 引入了新的 for await...of 语句，可用来遍历异步可迭代对象。异步可迭代对象通过 Symbol.asyncIterator 符号来指定默认的异步迭代器，如果一个对象设置了</description></item><item><title>解决 PHP Trait 不能定义常量及成员变量冲突的问题</title><link>https://www.fournoas.com/posts/how-to-resolve-php-traits-cannot-have-constants-and-property-conflict/</link><pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-resolve-php-traits-cannot-have-constants-and-property-conflict/</guid><description>PHP Trait 只能定义成员变量和方法，不能定义常量。如下代码会报错： // test.php trait UsageTrait { const THE_CONST_NAME = 1; } 错误消息为： Fatal error: Traits cannot have constants in test.php 想要在不同的类中共用一组常量，可以通过接口来解决： interface UsageConstantsInterface { const THE_CONST_NAME = __CLASS__; } trait UsageTrait { public function usageForBar() { echo UsageConstantsInterface::THE_CONST_NAME, PHP_EOL; } public function usageForFoo() { // 如果使用 UsageTrait 的类实现了 UsageConstantsInterface 接口， // 也可以使用 self::THE_CONST_NAME 来访问常量 echo self::THE_CONST_NAME, PHP_EOL; } } class Foo implements UsageConstantsInterface { use UsageTrait;</description></item><item><title>小众编程语言</title><link>https://www.fournoas.com/posts/niche-programming-languages/</link><pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/niche-programming-languages/</guid><description>这里先给出小众的定义：以 TIOBE Index for October 2021 为标准，排名在 20 位以后的编程语言。其中排名前 20 的编程语言为： Python C Java C++ C# Visual Basic JavaScript SQL PHP Assembly language Classic Visual Basic Go MATLAB R Groovy Ruby Swift Fortran Perl Delphi/Object Pascal 在 TIOBE 榜单 20 至 100 位里的小众编程语言： Scratch (24) 麻省理工媒体实验室开发一款面向教学的编程工具。主要用于少儿编程教学。 Rust (26) 由 Mozilla 基金会主导开发的一款通</description></item><item><title>告别密码验证</title><link>https://www.fournoas.com/posts/say-goodbye-to-the-password-authentication/</link><pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/say-goodbye-to-the-password-authentication/</guid><description>最近，微软宣布所有用户现可从其帐户中完全删除密码。用户可以通过在手机上安装 Microsoft Authenticator 应用来接收验证码进行登录。详见《微软账户进入无密码时代，现可将你的密码彻底删除》： 微软副总裁 Vasu Jakkal 表示，“近年来，我们一直都在强调无密码机制的重要性。今天我在这里很高兴地向大家宣布，这项愿景终于有了实质性</description></item><item><title>无锁队列并非真的无锁</title><link>https://www.fournoas.com/posts/lock-free-queue-is-not-lock-free/</link><pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/lock-free-queue-is-not-lock-free/</guid><description>近几年经常被提起的无锁队列，似乎被视为解决高并发的万能良药。无锁队列是一种通过CPU提供的原子操作指令 CAS 和 FAA，以及循环重试，来实现的乐观并发控制算法。虽然无锁队列算法并未显式调用锁，但事实上，在多核环境下，所谓的无锁队列算法本质上就是实现了锁的功能。 首先，原子指令本身就是一种</description></item><item><title>「并行」和「并发」</title><link>https://www.fournoas.com/posts/parallel-and-concurrent/</link><pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/parallel-and-concurrent/</guid><description>从中文字面上还是挺难区分「并行」和「并发」的，两者都带着一个「并」，似乎是个同义词。而在计算机科学中，「并行」和「并发」完全是两个不同的概念。两者并非互斥，也有相关联，但含义绝不可混淆。 英文辨析 「并行」的英文是 parallel，「并发」的英文是 concurrent。有意思的是，台</description></item><item><title>flexbox 实现自适应图片九宫格布局</title><link>https://www.fournoas.com/posts/responsive-square-layout-with-flexbox/</link><pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/responsive-square-layout-with-flexbox/</guid><description>「九宫格」的布局是指：在一个正方形的容器中，以 3x3 排列共九个正方形的元素。当容器大小发生变化时，容器内部的九个元素尺寸也能随着容器大小而缩放，并保持正方形的外形。当容器内元素不满九个时，每行元素能够等比放大并撑满一行</description></item><item><title>如何使用 llhttp</title><link>https://www.fournoas.com/posts/how-to-use-llhttp/</link><pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-use-llhttp/</guid><description>llhttp 是 Node.js v12 以上版本使用的 HTTP 解析器，代替了旧版的 http_parser。根据官方宣传，相较于旧版解析器，新版本解析器性能提升了 156%。llhttp 的主要代码由 Typescript 实现，描述了一个有限状态机，最终通过 llparse 将代码转换成 C 语言源代码。然而官方文档里根本没写如何生成 C 语言代码，只能自己探索了。</description></item><item><title>Windows 下编译 libuv</title><link>https://www.fournoas.com/posts/build-libuv-for-windows/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/build-libuv-for-windows/</guid><description>在 Windows 下编译 libuv 需要先安装 Visual C++ Build Tools 和 CMake。 在 libuv 源代码目录下运行命令： mkdir build cd build cmake .. -DBUILD_TESTING=ON cd .. cmake --build --config Release build 编译成功后，可以在 build/Release 目录下找到生成的静态库和 DLL 动态库。 TL;DR 由于 libuv 项目在 Windows 下默认只支持 VC 编译器，cmake 生成的是 VS 项目文件。而 VS 项目属于 multi configuration，`-DCMAKE_</description></item><item><title>Python 库资源收集</title><link>https://www.fournoas.com/posts/python-libraries-and-packages/</link><pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-libraries-and-packages/</guid><description>收集了流行的 Python 库和资源。会不定期更新</description></item><item><title>Nim 语言的动态分发机制</title><link>https://www.fournoas.com/posts/dynamic-dispatch-in-nim-lang/</link><pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/dynamic-dispatch-in-nim-lang/</guid><description>Nim 是一款 Python 风格的静态类型语言。但事实上，除了缩进语法外，Nim 和 Python 并没有太多相似之处。相对于 Python，Nim 更多地吸收了 Ada 和 Lisp 等语言的特性。 Nim 编译器通过生成 C 或 Obj-C 中间代码的方式来进行本地编译，所以需要依赖一套外部编译器。Nim 也可以生成 Javascript 代码。此外，还有以脚本方式运行的 Nim</description></item><item><title>创建支持 Kotlin 协程的 Vert.x 服务代理</title><link>https://www.fournoas.com/posts/create-a-vert.x-service-proxy-with-kotlin-coroutine/</link><pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/create-a-vert.x-service-proxy-with-kotlin-coroutine/</guid><description>本文提供一个方法，可用于创建支持 Kotlin 协程的 Vert.x 服务代理</description></item><item><title>Laravel 强制 api 路由组返回 JSON</title><link>https://www.fournoas.com/posts/force-laravel-to-return-JSON-response-with-api-routes/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/force-laravel-to-return-JSON-response-with-api-routes/</guid><description>Laravel 的默认错误处理器通过 &lt;code>Illuminate\Http\Request&lt;/code> 的 &lt;code>expectsJson()&lt;/code> 方法来决定是否将错误信息渲染成 JSON 格式输出。这要求将请求头的 &lt;code>Accept&lt;/code> 字段设置为 &lt;code>application/json&lt;/code>。本文提供一种方法，在尽可能减少代码的情况下，强制让 api 路由组中的所有错误响应变成 JSON 格式，而不依赖于请求的 &lt;code>Accept&lt;/code> 头部</description></item><item><title>使用 Cloudflare 的源站缓存控制</title><link>https://www.fournoas.com/posts/using-cloudflares-origin-cache-control/</link><pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/using-cloudflares-origin-cache-control/</guid><description>Cloudflare 默认不缓存 HTML 页面，必须通过添加页面规则(Page Rule)来开启网页缓存。然而，免费用户每个站点最多只能添加三条规则。对于一个复杂的项目来说，三条规则是远远不够用的。通过设置源站缓存控制(Origin Cache Control)，可以仅使用一条规则来启用全站缓存。 启用 Cloudflare 全站缓存 进入 Cloudflare 站点</description></item><item><title>使用 Google Authenticator（谷歌身份验证器）</title><link>https://www.fournoas.com/posts/how-to-use-google-authenticator/</link><pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-use-google-authenticator/</guid><description>某些简单的业务场景需要一个管理后台，但是系统却没有复杂到需要引入一套用户体系。那么，谷歌身份验证器（Google Authenticator）可以作为管理后台的一种简单的身份认证方式。 Google Authenticator 是一款基于时间（TOTP）与哈希（HOTP）的一次性密码算法的两步验证软件令牌。其原理是通过密</description></item><item><title>Java 获取包中所有的类</title><link>https://www.fournoas.com/posts/get-all-classes-from-a-java-package/</link><pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/get-all-classes-from-a-java-package/</guid><description>刚接触 Java，没想到连这种基础功能都需要自己实现，而且还如此复杂。虽然最后也完成了实现代码，不过最后还是使用了 &lt;code>org.reflections&lt;/code> 第三方包。记录实现代码，万一以后用得到</description></item><item><title>Vert.x 项目自动重新部署</title><link>https://www.fournoas.com/posts/auto-redeploy-vertx-upon-code-change/</link><pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/auto-redeploy-vertx-upon-code-change/</guid><description>Vert.x 是一款基于 JVM 的高性能异步框架。使用官网提供的项目生成器创建的 gradle 配置有一个 BUG，导致在 Windows 环境下无法完成自动部署。 修复方法如下</description></item><item><title>让 Vagrant 共享目录支持文件事件通知</title><link>https://www.fournoas.com/posts/make-Vagrant-shared-folders-support-inotify-events/</link><pubDate>Wed, 08 Jan 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/make-Vagrant-shared-folders-support-inotify-events/</guid><description>问题 在使用 Vagrant 的过程中发现了一个问题：对于使用 config.vm.synced_folder 进行配置的共享文件夹，如果在 Host 系统（本地环境）中修改了其路径下的文件，在 Guest 系统（虚拟机环境）中是无法通过 inotifywait 接收到文件系统事件的。 而通常情况下，Vagrant 的共享目录是用来存放源代码的。我们会在 Host 系统中编辑源代码，在 Guest 系统中运行它们。</description></item><item><title>让 FastRoute 支持 URL 反向解析</title><link>https://www.fournoas.com/posts/make-FastRoute-support-url-reverse/</link><pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/make-FastRoute-support-url-reverse/</guid><description>&lt;a href="https://github.com/nikic/FastRoute" target="_blank" rel="noopener">FastRoute&lt;/a> 是一款高性能路由组件，需要运行于 PHP 7.1 及以上版本。很多 PHP Web 框架都用它作为默认路由。然而这款路由组件不支持 URL 反向解析。&lt;a href="https://www.hyperf.io/" target="_blank" rel="noopener">Hyperf&lt;/a> 框架也采用了这款路由组件，以下代码可以让 Hyperf 支持 URL 反向解析</description></item><item><title>Swoole 框架最佳实践</title><link>https://www.fournoas.com/posts/the-swoole-framework-best-practices/</link><pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-swoole-framework-best-practices/</guid><description>Swoole 是一种常驻内存进程 Reactor 模式的框架。 支持 Swoole 的 Web 框架： Laravel-Swoole Laravel-S Swoft Hyperf One EasySwoole 1 和 2 可以让 Swoole 支持 Laravel 框架；个人更倾向于 Hyperf；Swoft 很好，但也很重，如果要使用Swoft，不如考虑换个技术栈，比如 Java 或 Python。 优点 高性能 在 TechEmpower Framework Benchmarks 的测试中完胜 Node.js。 支持 Coroutine Coroutine 可以将步代码转换成异步</description></item><item><title>CQRS/Event Sourcing 模式实践</title><link>https://www.fournoas.com/posts/CQRS-and-event-sourcing-pattern-in-practice/</link><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/CQRS-and-event-sourcing-pattern-in-practice/</guid><description>如果还不清楚什么是 CQRS 和 Event Sourcing 模式，可以先阅读下面的两篇文章： 命令和查询责任分离模式 事件溯源模式 Event Sourcing 模式，即事件溯源模式。该模式使用只可追加的存储来记录对数据所进行的所有操作，而不是存储领域数据的当前状态。其中，存储 Event 记录的介质称作 Event Store。 CQRS（Command Query Responsibility Segre</description></item><item><title>Python Web 框架选型</title><link>https://www.fournoas.com/posts/choosing-a-python-web-framework/</link><pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/choosing-a-python-web-framework/</guid><description>Python Web 框架有如下几种部署方式： WSGI ASGI 独立部署 CGI/FastCGI WSGI是最常见的接口，由PEP333和PEP3333规范定义，获得了最广泛的支持。 WSGI接口的上游是HTTP Server，下游是WSGI应用，而提供WSGI服务的程序被称为WSGI容器。生产环境中常见的WSGI容器有Gunicorn、</description></item><item><title>ES6 中 Proxy 和 EventTarget 的 Mixin 模式</title><link>https://www.fournoas.com/posts/ES6-mixin-with-Proxy-and-EventTarget/</link><pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/ES6-mixin-with-Proxy-and-EventTarget/</guid><description>Javascript 不支持多重继承，也不支持原生类的 mixin。想实现一个具备 Proxy 和 EventTarget 多重功能的混合类</description></item><item><title>Gandi.net Simple Hosting 踩坑记录</title><link>https://www.fournoas.com/posts/Gandi-simple-hosting-sucks/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/Gandi-simple-hosting-sucks/</guid><description>Gandi.net 的廉价虚拟主机服务 Simple Hosting 支持PHP / Python / MySQL / Postgresql。 Gandi.net 建站全家桶性价比超级高。买域名送免费邮箱和SSL证书。Simple Hosting 服务的最低配，算上折扣，一年只要300多元。不过由于配置的问题，在实际运行中有很多坑要避开。 1、pip 日志写入权限问题 运行 pip 会提示没有权限，原因</description></item><item><title>编译安装 Python 时发生“Missing the OpenSSL lib”错误</title><link>https://www.fournoas.com/posts/the-python-ssl-extension-was-not-compiled-missing-the-OpenSSL-lib/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-python-ssl-extension-was-not-compiled-missing-the-OpenSSL-lib/</guid><description>使用pyenv在ubuntu18上安装多个python版本。按照文档，先安装编译依赖库： sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \ xz-utils tk-dev libffi-dev liblzma-dev python-openssl 使用 pyenv install -v x.x.x 命令来安装指定版本的python。在安装3.4及以下版本时会报错： ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib? 原因是ubuntu默认安装的libssl-d</description></item><item><title>编写兼容 python 2.7 和 3.5+ 的代码</title><link>https://www.fournoas.com/posts/writing-python-2.7-and-3.5-or-above-compatible-code/</link><pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/writing-python-2.7-and-3.5-or-above-compatible-code/</guid><description>编写新的代码最好不要再兼容 Python 2.6 及以下版本了，坑太多。兼容 2.7 就足够了。同样地，Python 3.5 及以下版本的坑也很多，Python 3 最好从 3.5 开始兼容。 导入模块 Python 3 默认绝对导入，Python 2 默认相对导入。所以代码第一行就应写上： from __future__ import absolute_import 异常处理 Python 2 和 3 异常处理语句有所差异，应使用新的异</description></item><item><title>Windows 下安装 Scrapy</title><link>https://www.fournoas.com/posts/how-to-install-Scrapy-in-Windows/</link><pubDate>Sat, 07 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-install-Scrapy-in-Windows/</guid><description>Scrapy 依赖的某些组件需要编译，所以需要安装 Visual C++ Build Tools（http://landinghub.visualstudio.com/visual-cpp-build-tools）。 另外可以在这里（https://www.lfd.uci.edu/~gohlke/pythonlibs/）找</description></item><item><title>npm 安装 electron 出错的解决方法</title><link>https://www.fournoas.com/posts/install-electron-using-npm-issue/</link><pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/install-electron-using-npm-issue/</guid><description>问题 使用命令 npm install -g electron 安装 electronjs 时报错： 出错信息表明下载 electron 的地址被墙掉了。 解决方案 使用淘宝镜像。设置环境变量： set ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ 然后再用命令安装： npm install -g electron</description></item><item><title>PHP 和 Python 速查手册</title><link>https://www.fournoas.com/posts/php-and-python-quick-start-guide/</link><pubDate>Mon, 28 Dec 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/php-and-python-quick-start-guide/</guid><description>部署方式 PHP 的部署方式 PHP 程序有如下几种运行方式： CGI FastCGI ISAPI Extension Apache Mod 其中，CGI 和 FastCGI 以进程的方式运行，使用 nts（非线程安全）版本； ISAPI Extension 和 Apache Mod 以线程方式运行在宿主进程（IIS进程或Apache进程）内，使用 ts（线程安全）版本。 以上几种方式以 FastCGI 最为常见。PHP 5 自带的 php-cgi 可以直接运行 FastCGI 服务。</description></item><item><title>使用 Vagrant 作为开发环境</title><link>https://www.fournoas.com/posts/setting-up-your-development-environment-using-vagrant/</link><pubDate>Mon, 28 Dec 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/setting-up-your-development-environment-using-vagrant/</guid><description>初始化虚拟机环境 下载 ubuntu-15.04-amd64.box 包文件。使用离线安装的方式： &amp;gt; vagrant box add ubuntu-15.04-amd64 file:///D:\downloads\ubuntu-15.04-amd64.box 其中 D:\downloads\ubuntu-15.04-amd64.box 是下载后的 box 文件路径。 切换到项目路径下，初始化并启动 Vagrant： mkdir ~/project/devstack cd ~/project/devstack vagrant init ubuntu-15.04-amd64 启动并登录虚拟机系统 vagrant up vagrant ssh 安装软件 更新 apt 软件库： sudo apt-get update -y sudo apt-get upgrade -y 安装需要的软件包： sudo apt-get install -y git ansible libmysqld-dev mysql-server mongodb-server redis-server nginx-full supervisor uwsgi uwsgi-plugin-python python-pip python-dev python-virtualenv python-mysqldb python-mongoengine python-redis python-gevent virtualenvwrapper php5</description></item><item><title>HTML Entities 转换问题</title><link>https://www.fournoas.com/posts/issue-with-convert-HTML-entities/</link><pubDate>Fri, 23 Oct 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/issue-with-convert-HTML-entities/</guid><description>用 Python 给富文本编辑器的后端做一个 HTMLPurifier 组件。各种 XSS 技巧都筛了一遍。觉得万无一失了，没想到还是栽在了坑里。 HTMLPurifier 组件使用 Python HTMLParser 来实现。HTMLParser 在处理 HTML Entities 的时候和主流的浏览器不一致。主流浏览器（FireFox、Chrome、IE）都允许省略HTML Entities末尾的分号。而 HTMLParser 的u</description></item><item><title>一个语言的诞生（Act IV）</title><link>https://www.fournoas.com/posts/the-birth-of-a-language-4/</link><pubDate>Sat, 15 Aug 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-birth-of-a-language-4/</guid><description>第四幕 虚拟机指令设计 常见的两种物理处理器指令架构有：复杂指令集（CISC）、简单指令集（RISC）。前者的代表是 Intel x86 处理器，后者的代表有 MIPS、SPARC 和 ARM。 CISC 指令集的指令长度不等，多种寻址方式</description></item><item><title>一个语言的诞生（Act III）</title><link>https://www.fournoas.com/posts/the-birth-of-a-language-3/</link><pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-birth-of-a-language-3/</guid><description>第三幕 垃圾回收 看过微软 .net coreclr 的源代码后，觉得 Lua、PHP 和 Python 的垃圾回收代码与之相比简直就是个玩具。而 Hotspot JVM 的垃圾回收算法更加复杂。 常见的垃圾回收技术能大致分成：引用计数、标记清理、标记缩并和节点复制几种。高级的技术有垃圾分代收集、渐进及并发收集、分布式垃圾收集。复杂的垃圾回收算法会</description></item><item><title>一个语言的诞生（Act II）</title><link>https://www.fournoas.com/posts/the-birth-of-a-language-2/</link><pubDate>Sun, 12 Jul 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-birth-of-a-language-2/</guid><description>第二幕 对象内存布局 那些不怎么“动态”的语言，比如C#和JAVA，一般都会把数据类型分成“值”和“引用”，值类型是分配在栈上的，引用类型是分配在堆上。而“动态”的语言，比如“PHP”和“Python”所有的数据都是动态分配在堆上的。这么做的缺点一是浪费内存，二是访问慢。浪费内存是因</description></item><item><title>一个语言的诞生（Act I）</title><link>https://www.fournoas.com/posts/the-birth-of-a-language-1/</link><pubDate>Sat, 11 Jul 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-birth-of-a-language-1/</guid><description>第一幕 哈希表 哈希表是动态脚本语言的基石。动态语言中，全局变量表、全局字符串表、对象虚函数表、元数据表皆为哈希表。欲实现语言，则必先实现哈希表。 哈希表原理很简单，不再赘述。不同语言实现的哈希表主要区别在于处理碰撞的机制不同。一种叫“Separate chaining”，PHP的哈希表</description></item><item><title>一个语言的诞生（Prologue）</title><link>https://www.fournoas.com/posts/the-birth-of-a-language-prologue/</link><pubDate>Sat, 11 Jul 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-birth-of-a-language-prologue/</guid><description>一直琢磨着自己实现一个脚本语言。因为懒，直到最近才动手。 构想中的语言语法类似ActionScript，支持GC、闭包、Lambda表达式、协程、尾递归优化、迭代器/生成器、允许（编译期）强类型绑定的可嵌入式动态脚本语言。基础类型支持NULL、布尔型、32位整型、64位长整型、双精</description></item><item><title>跨平台 C 语言开发</title><link>https://www.fournoas.com/posts/cross-platform-development-using-c-lang/</link><pubDate>Fri, 26 Jun 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/cross-platform-development-using-c-lang/</guid><description>通过 WIN32 宏来判断是否为 Windows 平台。64位 Windows 也会定义 WIN32 宏，此外还定义 WIN64 宏，有些编译器可能是 Windows、__WIN32__、WIN32、_WIN64 通过 _MSC_VER 宏判断是否是VC编译器 通过 __GNUC__ 宏来判断是否为 gcc 编译器 Windows 平台上的 gcc 编译器支持__declspec(dllimport) 和 __declspec(dllexport) Linux 平台上 gcc 通过</description></item><item><title>Lua 源代码中的字节对齐</title><link>https://www.fournoas.com/posts/data-structure-alignment-in-lua-source-code/</link><pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/data-structure-alignment-in-lua-source-code/</guid><description>Lua 源码中定义了一个叫 L_Umaxalign 的数据类型： typedef union { double u; void *s; lua_Integer i; long l; } L_Umaxalign; 这个结构其实是该平台上最长的数据类型。然后和 TString 和 Udata 结构定义成一个联合体： typedef union UTString { L_Umaxalign dummy; /* ensures maximum alignment for strings */ TString tsv; } UTString; typedef union UUdata { L_Umaxalign dummy; /* ensures maximum alignment for 'local' udata */ Udata uv; } UUdata; 之所以这样处理是因为 TString 和 Udata 其实是一块连续内存区域的头部，后面紧跟实体数据。为了</description></item><item><title>PHP 中的服务定位和依赖注入</title><link>https://www.fournoas.com/posts/service-locator-and-dependency-injection-in-php/</link><pubDate>Tue, 04 Jun 2013 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/service-locator-and-dependency-injection-in-php/</guid><description>尝试了很多PHP框架，有轻量级的，也有企业级的，发现解耦都做得很不好，自由度都很差。Zend framework2.0 做得还不错，就是封装太多，不够轻量。 一、创建对象 从最原始的new操作符，到abstract factory或builder等经典创建模式，都不能满足人民群众日益高涨的解耦需求。后来，MF创</description></item><item><title>MSN 双开工具源代码</title><link>https://www.fournoas.com/posts/MSN-multi-clienting-tool-source-code/</link><pubDate>Sat, 04 Feb 2006 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/MSN-multi-clienting-tool-source-code/</guid><description>网上偶然拾得本人于 2006 年所写的 &lt;strong>MSN Messenger&lt;/strong> 双/多开工具的源代码。此即时通讯软件早于 2013 年便已停止服务，而今再看昔日所写代码不甚感慨，遂记录于此，以兹纪念</description></item></channel></rss>