<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Python 自 3.5 版本起，至当前 3.11 版本为止，变化相当大，引入了众多的新特性，了解这些变化对编写兼容性代码尤为重要。本文整理的一些版本的重要变化。 Python 3.5 此版本最早发布于 2015 年，最终版本为 3.5.10 ，发布于 2020 年。 [PEP 492] 使用 async/await 语法实现协程 见 PEP 492 。 此特性是 3.5 版本最重大的变化。自此，Python 支持 async 和 await 语法，用于"><title>Python 3.5 之后的新特性 &#183; 白汤四物</title>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/rainbow.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href rel=alternate type=application/rss+xml title=白汤四物><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-3GNL63B62Q"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3GNL63B62Q")</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/search/><span>搜索</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main data-pagefind-body><div class="page post"><h1 class=post-title data-pagefind-meta=title>Python 3.5 之后的新特性</h1><div class=post-line></div><div class=post-info><span>作者</span>
<span data-pagefind-meta=作者>Fournoas
</span><span>于&nbsp;</span><time datetime="2022-12-06 00:00:00 +0000 UTC" data-pagefind-meta=日期>2022年12月6日</time>
<span>发布在&nbsp;</span><ul class=categories><li><a data-pagefind-filter=分类 href=/categories/coding/>Coding</a></li></ul></div><nav id=TableOfContents><ul><li><a href=#python-35>Python 3.5</a><ul><li><a href=#pep-492-使用-asyncawait-语法实现协程>[PEP 492] 使用 <code>async</code>/<code>await</code> 语法实现协程</a></li><li><a href=#pep-448-通用化额外的解包操作>[PEP 448] 通用化额外的解包操作</a></li><li><a href=#pep-484-类型提示>[PEP 484] 类型提示</a></li><li><a href=#其他>其他</a></li></ul></li><li><a href=#python-36>Python 3.6</a><ul><li><a href=#pep-487-魔术方法-__init_subclass__-和-__set_name__>[PEP 487] 魔术方法 <code>__init_subclass__</code> 和 <code>__set_name__</code></a></li><li><a href=#pep-498-格式化字符串字面值>[PEP 498] 格式化字符串字面值</a></li><li><a href=#pep-526-变量注解语法>[PEP 526] 变量注解语法</a></li><li><a href=#pep-468-保持-kwargs-传参时的顺序>[PEP 468] 保持 <code>**kwargs</code> 传参时的顺序</a></li><li><a href=#字典对象会保持插入时的顺序>字典对象会保持插入时的顺序</a></li><li><a href=#其他-1>其他</a></li></ul></li><li><a href=#python-37>Python 3.7</a><ul><li><a href=#pep-562-模块的-__getattr__-和-__dir__>[PEP 562] 模块的 <code>__getattr__</code> 和 <code>__dir__</code></a></li><li><a href=#pep-557-新增模块-dataclasses>[PEP 557] 新增模块 <code>dataclasses</code></a></li><li><a href=#pep-567-新增模块-contextvars>[PEP 567] 新增模块 <code>contextvars</code></a></li><li><a href=#其他-2>其他</a></li></ul></li><li><a href=#python-38>Python 3.8</a><ul><li><a href=#pep-572-赋值表达式>[PEP 572] 赋值表达式</a></li><li><a href=#pep-570-仅限位置形参>[PEP 570] 仅限位置形参</a></li><li><a href=#其他-3>其他</a></li></ul></li><li><a href=#python-39>Python 3.9</a><ul><li><a href=#pep-584-字典合并操作符->[PEP 584] 字典合并操作符 <code>|</code></a></li><li><a href=#pep-616-字符串新增-removeprefix-和-removesuffix-方法>[PEP 616] 字符串新增 <code>removeprefix()</code> 和 <code>removesuffix()</code> 方法</a></li><li><a href=#其他-4>其他</a></li></ul></li><li><a href=#python-310>Python 3.10</a><ul><li><a href=#pep-617-带括号的上下文管理器>[PEP 617] 带括号的上下文管理器</a></li><li><a href=#pep-604-允许-x--y-形式的联合类型写法>[PEP 604] 允许 X | Y 形式的联合类型写法</a></li><li><a href=#pep-634-结构模式匹配>[PEP 634] 结构模式匹配</a></li><li><a href=#其他-5>其他</a></li></ul></li><li><a href=#python-311>Python 3.11</a><ul><li><a href=#pep-654-exceptiongroup-和-except>[PEP 654] <code>ExceptionGroup</code> 和 <code>except*</code></a></li><li><a href=#pep-678-新增方法-baseexceptionadd_note>[PEP 678] 新增方法 <code>BaseException.add_note()</code></a></li><li><a href=#其他-6>其他</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav><div id=collapsed-toc><a class=button><i class="fa-solid fa-bars"></i></a></div><aside id=aside-toc data-pagefind-ignore><div class=header><i class="fa-solid fa-bars"></i>&nbsp;章节目录<a class="button close"><i class="fa-solid fa-xmark"></i></a></div><div class=content></div></aside><p>Python 自 3.5 版本起，至当前 3.11 版本为止，变化相当大，引入了众多的新特性，了解这些变化对编写兼容性代码尤为重要。本文整理的一些版本的重要变化。</p><h2 id=python-35>Python 3.5</h2><p>此版本最早发布于 2015 年，最终版本为 3.5.10 ，发布于 2020 年。</p><h3 id=pep-492-使用-asyncawait-语法实现协程>[PEP 492] 使用 <code>async</code>/<code>await</code> 语法实现协程</h3><p>见 <a href=https://peps.python.org/pep-0492/ target=_blank rel=noopener>PEP 492</a> 。</p><p>此特性是 3.5 版本最重大的变化。自此，Python 支持 <code>async</code> 和 <code>await</code> 语法，用于代替 <code>@asyncio.coroutine</code> 装饰器和 <code>yield from</code> 语句。</p><h3 id=pep-448-通用化额外的解包操作>[PEP 448] 通用化额外的解包操作</h3><p>见 <a href=https://peps.python.org/pep-0448/ target=_blank rel=noopener>PEP 448</a> 。</p><p>解包即 <code>*</code> 和 <code>**</code> 操作，曾在传递列表和字典类型的函数参数时使用。新特性将这一操作推广到了其他使用场景。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>*range(4), 4 # (0, 1, 2, 3, 4)
[*range(4), 4] # [0, 1, 2, 3, 4]
{*range(4), 4} # {0, 1, 2, 3, 4}
{&#39;x&#39;: 1, **{&#39;y&#39;: 2}} # {&#39;x&#39;: 1, &#39;y&#39;: 2}</code></pre><h3 id=pep-484-类型提示>[PEP 484] 类型提示</h3><p>见 <a href=https://peps.python.org/pep-0484/ target=_blank rel=noopener>PEP 484</a> 。</p><p>支持函数和方法的参数及返回值的类型提示：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>def greeting(name: str) -&gt; str:
    return &#39;Hello &#39; &#43; name</code></pre><p>还有对泛型的支持：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>from typing import Mapping, Set

def notify_by_email(employees: Set[Employee], overrides: Mapping[str, str]) -&gt; None:
    pass</code></pre><pre><span class=code-lang>PYTHON</span><code class=language-python>from typing import Sequence, TypeVar

T = TypeVar(&#39;T&#39;)      # Declare type variable

def first(l: Sequence[T]) -&gt; T:   # Generic function
    return l[0]</code></pre><h3 id=其他>其他</h3><ul><li>[<a href=https://peps.python.org/pep-0465/ target=_blank rel=noopener>PEP 465</a>] 矩阵乘法运算符 <code>@</code></li><li>[<a href=https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-461 target=_blank rel=noopener>PEP 461</a>] bytes 和 bytearray 支持 <code>%</code> 格式化</li><li>[<a href=https://peps.python.org/pep-0484/ target=_blank rel=noopener>PEP 484</a>] 新增模块 <a href=https://docs.python.org/3/library/typing.html#module-typing target=_blank rel=noopener><code>typing</code></a></li><li>[<a href=https://peps.python.org/pep-0441/ target=_blank rel=noopener>PEP 441</a>] 新增模块 <a href=https://docs.python.org/3/library/zipapp.html#module-zipapp target=_blank rel=noopener><code>zipapp</code></a></li></ul><h2 id=python-36>Python 3.6</h2><p>此版本最早发布于 2016 年，最终版本为 3.6.15 ，发布于 2021 年。</p><h3 id=pep-487-魔术方法-__init_subclass__-和-__set_name__>[PEP 487] 魔术方法 <code>__init_subclass__</code> 和 <code>__set_name__</code></h3><p>见 <a href=https://peps.python.org/pep-0487/ target=_blank rel=noopener>PEP 487</a> 。</p><p>当声明或创建新的子类时，基类的 <a href=https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init_subclass__ target=_blank rel=noopener><code>__init_subclass__</code></a> 方法将会被调用：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>class PluginBase:
    subclasses = []

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        cls.subclasses.append(cls)

class Plugin1(PluginBase):
    pass

class Plugin2(PluginBase):
    pass</code></pre><p>当一个类被创建时，<code>type.__new__()</code> 会扫描类变量并对其中带有 <a href=https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set_name__ target=_blank rel=noopener><code>__set_name__</code></a> 方法的对象执行回调。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>class A:
    def __set_name__(self, owner, name):
        print(owner, name)

class B:
    a = A() # 隐含调用 a.__set_name__(B, &#39;a&#39;)</code></pre><h3 id=pep-498-格式化字符串字面值>[PEP 498] 格式化字符串字面值</h3><p>见 <a href=https://peps.python.org/pep-0498/ target=_blank rel=noopener>PEP 498</a> 。</p><p>新增字符串前缀 <code>f</code> ，实现类似 <a href=https://docs.python.org/3/library/stdtypes.html#str.format target=_blank rel=noopener><code>str.format()</code></a> 的效果。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>name = &#34;Fred&#34;
f&#34;He said his name is {name}.&#34;

width = 10
precision = 4
value = decimal.Decimal(&#34;12.34567&#34;)
f&#34;result: {value:{width}.{precision}}&#34;  # nested fields</code></pre><h3 id=pep-526-变量注解语法>[PEP 526] 变量注解语法</h3><p>见 <a href=https://peps.python.org/pep-0526/ target=_blank rel=noopener>PEP 526</a> 。</p><p>继 PEP 484 支持函数参数和返回值的类型提示后，此 PEP 增进了对变量类型的声明支持。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>primes: List[int] = []

captain: str  # Note: no initial value!

class Starship:
    stats: Dict[str, int] = {}</code></pre><h3 id=pep-468-保持-kwargs-传参时的顺序>[PEP 468] 保持 <code>**kwargs</code> 传参时的顺序</h3><p>见 <a href=https://peps.python.org/pep-0468/ target=_blank rel=noopener>PEP 468</a> 。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>kwargs = {&#39;z&#39;: 1, &#39;a&#39;: 2, &#39;x&#39;: 3, &#39;c&#39;: 4}

def ordered_kwargs(**kwargs):
    print(kwargs)

ordered_kwargs(**kwargs) # {&#39;z&#39;: 1, &#39;a&#39;: 2, &#39;x&#39;: 3, &#39;c&#39;: 4}</code></pre><h3 id=字典对象会保持插入时的顺序>字典对象会保持插入时的顺序</h3><p>也就是说默认的 <code>dict()</code> 对象已经具有 <code>OrderedDict</code> 的特性。此外，类属性也会保持定义时的顺序。</p><h3 id=其他-1>其他</h3><ul><li>[<a href=https://peps.python.org/pep-0519/ target=_blank rel=noopener>PEP 519</a>] 添加文件系统路径协议</li><li>[<a href=https://peps.python.org/pep-0528/ target=_blank rel=noopener>PEP 528</a>] Windows 文件系统和控制台编码使用 UTF-8</li><li>[<a href=https://peps.python.org/pep-0506/ target=_blank rel=noopener>PEP 506</a>] 新增模块 <a href=https://docs.python.org/3/library/secrets.html#module-secrets target=_blank rel=noopener><code>secrets</code></a></li><li>[<a href=https://peps.python.org/pep-0525/ target=_blank rel=noopener>PEP 525</a>] 异步生成器</li><li>[<a href=https://peps.python.org/pep-0530/ target=_blank rel=noopener>PEP 530</a>] 异步推导式：在推导式中使用 <code>await</code> 和 <code>async for</code></li><li>[<a href=https://peps.python.org/pep-0515/ target=_blank rel=noopener>PEP 515</a>] 数字字面值可加入下划线<pre><span class=code-lang>PYTHON</span><code class=language-python>1_000_000_000_000_000 # 1000000000000000
0x_FF_FF_FF_FF # 4294967295</code></pre></li></ul><h2 id=python-37>Python 3.7</h2><p>此版本最早发布于 2018 年，最新版本为 3.7.15 ，发布于 2022 年。</p><h3 id=pep-562-模块的-__getattr__-和-__dir__>[PEP 562] 模块的 <code>__getattr__</code> 和 <code>__dir__</code></h3><p>见 <a href=https://peps.python.org/pep-0562/ target=_blank rel=noopener>PEP 562</a> 。</p><p>允许在模块上定义 <code>__getattr__()</code> 并且当以其他方式找不到某个模块属性时将会调用它。 还可以在模块上定义 <code>__dir__()</code> 。</p><h3 id=pep-557-新增模块-dataclasses>[PEP 557] 新增模块 <code>dataclasses</code></h3><p>见 <a href=https://peps.python.org/pep-0557/ target=_blank rel=noopener>PEP 557</a> 。</p><p>提供一个类装饰器，可以为类自动添加诸如 <code>__init__()</code> 、 <code>__repr__()</code> 、 <code>__eq__()</code> 、 <code>__hash__()</code> 等魔术方法。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>import dataclasses

@dataclasses.dataclass
class Point:
    x: float
    y: float
    z: float = 0.0

p = Point(1.5, 2.5)
print(p)   # produces &#34;Point(x=1.5, y=2.5, z=0.0)&#34;</code></pre><h3 id=pep-567-新增模块-contextvars>[PEP 567] 新增模块 <code>contextvars</code></h3><p>见 <a href=https://peps.python.org/pep-0567/ target=_blank rel=noopener>PEP 567</a> 。</p><p>用于异步和并发环境中管理上下文变量。可以替代 <a href=https://docs.python.org/zh-cn/3/library/threading.html#threading.local target=_blank rel=noopener><code>threading.local()</code></a> 。</p><h3 id=其他-2>其他</h3><ul><li>新增模块 <a href=https://docs.python.org/3/library/importlib.resources.html#module-importlib.resources target=_blank rel=noopener><code>importlib.resources</code></a></li><li>[<a href=https://peps.python.org/pep-0553/ target=_blank rel=noopener>PEP 553</a>] 新增内建函数 <a href=https://docs.python.org/3/library/functions.html#breakpoint target=_blank rel=noopener><code>breakpoint()</code></a></li><li>[<a href=https://peps.python.org/pep-0564/ target=_blank rel=noopener>PEP 564</a>] time 模块支持纳秒精度</li></ul><h2 id=python-38>Python 3.8</h2><p>此版本最早发布于 2019 年，最新版本为 3.8.15 ，发布于 2022 年。</p><h3 id=pep-572-赋值表达式>[PEP 572] 赋值表达式</h3><p>见 <a href=https://peps.python.org/pep-0572/ target=_blank rel=noopener>PEP 572</a> 。</p><p>新增 <code>:=</code> 赋值表达式语法，表达式将右值赋予左值并返回该值。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>if (n := len(a)) &gt; 10:
    print(f&#34;List is too long ({n} elements, expected &lt;= 10)&#34;)</code></pre><h3 id=pep-570-仅限位置形参>[PEP 570] 仅限位置形参</h3><p>见 <a href=https://peps.python.org/pep-0570/ target=_blank rel=noopener>PEP 570</a> 。</p><p>函数参数中的 <code>/</code> 左边的参数为位置参数，不能作为关键字参数使用；而 <code>*</code> 右边的参数必须作为关键字参数使用。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)

# valid
f(10, 20, 30, d=40, e=50, f=60)
# invalid
f(10, b=20, c=30, d=40, e=50, f=60)   # b cannot be a keyword argument
f(10, 20, 30, 40, 50, f=60)           # e must be a keyword argument</code></pre><h3 id=其他-3>其他</h3><ul><li>格式化字符串支持文档化：<code>f'{expr=}'</code></li></ul><h2 id=python-39>Python 3.9</h2><p>此版本最早发布于 2020 年，最新版本为 3.9.15 ，发布于 2022 年。</p><h3 id=pep-584-字典合并操作符->[PEP 584] 字典合并操作符 <code>|</code></h3><p>见 <a href=https://peps.python.org/pep-0584/ target=_blank rel=noopener>PEP 584</a> 。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>d = {&#39;spam&#39;: 1, &#39;eggs&#39;: 2, &#39;cheese&#39;: 3}
e = {&#39;cheese&#39;: &#39;cheddar&#39;, &#39;aardvark&#39;: &#39;Ethel&#39;}
d | e # {&#39;spam&#39;: 1, &#39;eggs&#39;: 2, &#39;cheese&#39;: &#39;cheddar&#39;, &#39;aardvark&#39;: &#39;Ethel&#39;}
e | d # {&#39;cheese&#39;: 3, &#39;aardvark&#39;: &#39;Ethel&#39;, &#39;spam&#39;: 1, &#39;eggs&#39;: 2}</code></pre><h3 id=pep-616-字符串新增-removeprefix-和-removesuffix-方法>[PEP 616] 字符串新增 <code>removeprefix()</code> 和 <code>removesuffix()</code> 方法</h3><p>见 <a href=https://peps.python.org/pep-0616/ target=_blank rel=noopener>PEP 616</a> 。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>def strip_quotes(text):
    return text.removeprefix(&#39;&#34;&#39;).removesuffix(&#39;&#34;&#39;)</code></pre><h3 id=其他-4>其他</h3><ul><li>[<a href=https://peps.python.org/pep-0585/ target=_blank rel=noopener>PEP 585</a>] 类型提示泛型使用标准数据类型</li><li>[<a href=https://peps.python.org/pep-0614/ target=_blank rel=noopener>PEP 614</a>] 放宽对装饰器的语法限制</li><li>[<a href=https://peps.python.org/pep-0593/ target=_blank rel=noopener>PEP 593</a>] 新增 <a href=https://docs.python.org/3/library/typing.html#typing.Annotated target=_blank rel=noopener><code>typing.Annotated</code></a></li><li>[<a href=https://peps.python.org/pep-0615/ target=_blank rel=noopener>PEP 615</a>] 新增模块 <a href=https://docs.python.org/3/library/zoneinfo.html#module-zoneinfo target=_blank rel=noopener><code>zoneinfo</code></a></li></ul><h2 id=python-310>Python 3.10</h2><p>此版本最早发布于 2021 年，最新版本为 3.10.8 ，发布于 2022 年。</p><h3 id=pep-617-带括号的上下文管理器>[PEP 617] 带括号的上下文管理器</h3><p>见 <a href=https://peps.python.org/pep-0617/ target=_blank rel=noopener>PEP 617</a> 。</p><p>此特性在 3.9 版本时已经存在，但是在 3.10 版本时可以正式使用。<code>with</code> 语句括号内支持多行表达式：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>with (
    open(&#34;a_really_long_foo&#34;) as foo,
    open(&#34;a_really_long_baz&#34;) as baz,
    open(&#34;a_really_long_bar&#34;) as bar
):
    pass</code></pre><h3 id=pep-604-允许-x--y-形式的联合类型写法>[PEP 604] 允许 X | Y 形式的联合类型写法</h3><p>见 <a href=https://peps.python.org/pep-0604/ target=_blank rel=noopener>PEP 604</a> 。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>isinstance(5, int | str)

def f(list: List[int | str], param: int | None) -&gt; float | str:
    pass

int | str == typing.Union[int, str] # true</code></pre><h3 id=pep-634-结构模式匹配>[PEP 634] 结构模式匹配</h3><p>见 <a href=https://peps.python.org/pep-0634/ target=_blank rel=noopener>PEP 634</a> 、 <a href=https://peps.python.org/pep-0635/ target=_blank rel=noopener>PEP 635</a> 、 <a href=https://peps.python.org/pep-0636/ target=_blank rel=noopener>PEP 636</a> 。</p><p>新增 <code>match...case</code> 语法。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>command = &#39;drop doc1 doc2 doc3&#39;

match command.split():
    case [&#34;quit&#34;]: pass
    case [&#34;go&#34;, direction]: pass
    case [&#34;drop&#34;, *objects]: pass
    case _:
        print(f&#34;Sorry, I couldn&#39;t understand {command!r}&#34;)</code></pre><h3 id=其他-5>其他</h3><ul><li>[<a href=https://peps.python.org/pep-0626/ target=_blank rel=noopener>PEP 626</a>] 在调试和其他工具中使用精确的行号</li><li>[<a href=https://peps.python.org/pep-0632/ target=_blank rel=noopener>PEP 632</a>] 弃用 <code>distutils</code> 模块</li><li>[<a href=https://peps.python.org/pep-0647/ target=_blank rel=noopener>PEP 647</a>] 用户定义的类型检查函数 <a href=https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeGuard target=_blank rel=noopener><code>typing.TypeGuard</code></a></li><li>[<a href=https://peps.python.org/pep-0612/ target=_blank rel=noopener>PEP 612</a>] 参数规范变量 <a href=https://docs.python.org/zh-cn/3/library/typing.html#typing.ParamSpec target=_blank rel=noopener><code>typing.ParamSpec</code></a></li><li>[<a href=https://peps.python.org/pep-0613/ target=_blank rel=noopener>PEP 613</a>] 显式类型别名 <a href=https://docs.python.org/zh-tw/3.11/library/typing.html#typing.TypeAlias target=_blank rel=noopener><code>typing.TypeAlias</code></a></li></ul><h2 id=python-311>Python 3.11</h2><p>此版本今年刚发布 3.11.0 版本。</p><h3 id=pep-654-exceptiongroup-和-except>[PEP 654] <code>ExceptionGroup</code> 和 <code>except*</code></h3><p>见 <a href=https://peps.python.org/pep-0654/ target=_blank rel=noopener>PEP 654</a> 。</p><p><code>ExceptionGroup</code> 可以包含多个异常。<code>except*</code> 可以用来捕获 <code>ExceptionGroup</code> 中包含的异常。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>try:
    raise ExceptionGroup(&#39;error&#39;, [TypeError(1), ValueError(2)])
except* TypeError as e:
    print(f&#39;*TypeError: {e!r}&#39;)
except* ValueError as e:
    print(f&#39;*ValueError: {e!r}&#39;)</code></pre><h3 id=pep-678-新增方法-baseexceptionadd_note>[PEP 678] 新增方法 <code>BaseException.add_note()</code></h3><p>见 <a href=https://peps.python.org/pep-0678/ target=_blank rel=noopener>PEP 678</a> 。</p><p>可以为异常添加字符串类型的 note ，并可以通过 <code>__notes__</code> 属性读取。</p><pre><span class=code-lang>PYTHON</span><code class=language-python>exc = ValueError()
exc.add_note(&#39;note1&#39;)
exc.add_note(&#39;note2&#39;)
exc.add_note(&#39;note3&#39;)
print(exc.__notes__) # [&#39;note1&#39;, &#39;note2&#39;, &#39;note3&#39;]</code></pre><h3 id=其他-6>其他</h3><ul><li>[<a href=https://peps.python.org/pep-0593/ target=_blank rel=noopener>PEP 680</a>] 新增模块 <a href=https://docs.python.org/zh-cn/3/library/tomllib.html#module-tomllib target=_blank rel=noopener><code>tomllib</code></a></li><li>[<a href=https://peps.python.org/pep-0657/ target=_blank rel=noopener>PEP 657</a>] 更精细的错误显示</li><li>更多 <code>typing</code> 模块的改进：<ul><li>[<a href=https://peps.python.org/pep-0646/ target=_blank rel=noopener>PEP 646</a>] Variadic generics</li><li>[<a href=https://peps.python.org/pep-0655/ target=_blank rel=noopener>PEP 655</a>] Marking individual TypedDict items as required or not-required</li><li>[<a href=https://peps.python.org/pep-0673/ target=_blank rel=noopener>PEP 673</a>] Self type</li><li>[<a href=https://peps.python.org/pep-0675/ target=_blank rel=noopener>PEP 675</a>] Arbitrary literal string type</li><li>[<a href=https://peps.python.org/pep-0681/ target=_blank rel=noopener>PEP 681</a>] Data class transforms</li></ul></li></ul><h2 id=总结>总结</h2><p>迄今为止，<code>asyncio</code> 模块已经相当完善了，以后的网络开发可以完全基于异步和协程。最近几次版本升级，更新重点还是在 <code>typing</code> 模块。感觉 Python 的泛型还不够完善，且过于复杂。<code>typing</code> 模块还不够稳定，不建议深度使用。千呼万唤的模式匹配语法终于在 3.10 里实现了，以后不用再写可悲的 <code>if</code> 嵌套。</p></div><div class=taxonomy data-pagefind-ignore><div class=taxonomy-tags><ul class=tags><li>#<a data-pagefind-filter=标签 href=/tags/Python/>Python</a></li></ul></div></div><div class=pagination data-pagefind-ignore><a href=/posts/prevent-webrtc-ip-leak-on-web-browser/ class="left arrow">上一篇：<br>阻止浏览器 WebRTC 泄露真实 IP 地址</a>
<a href=/posts/socks5-proxy-protocol-quick-start/ class="right arrow">下一篇：<br>快速了解 SOCKS5 代理协议</a>
<a href=# class=top>返回顶部</a></div></main><script src=/js/page.js></script><script src=/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scala.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/nim.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/powershell.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/nginx.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/delphi.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dos.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/haxe.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=/js/code.js></script><script>hljs.highlightAll(),hljs.initLineNumbersOnLoad(),hljs.initSelectLines()</script><footer><span>&copy; <time datetime="2024-03-18 02:29:39.785724375 +0000 UTC m=+0.693122021">2024</time> fournoas.com. Powered by <a href=https://gohugo.io>Hugo</a>.</span></footer></body></html>