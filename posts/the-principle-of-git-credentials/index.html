<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="提出问题 Git 支持三种远程访问协议，分别是：SSH、HTTP/HTTPS 以及 git 协议。国内的 GitHub 用户通常会选择使用 HTTPS 协议，主要原因是该协议可以通过 HTTP 代理服务器来访问 GitHub。 使用 HTTPS 协议的不便之处在于每次请求都需要提供用户名和密码。因此，Git 通过一个用户凭证管理系统来解决这个问题，这"><title>Git Credentials 原理 &#183; 白汤四物</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/rainbow.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href rel=alternate type=application/rss+xml title=白汤四物><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-3GNL63B62Q"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3GNL63B62Q")</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/search/><span>搜索</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main data-pagefind-body><div class="page post"><h1 class=post-title data-pagefind-meta=title>Git Credentials 原理</h1><div class=post-line></div><div class=post-info><span>作者</span>
<span data-pagefind-meta=作者>Fournoas</span>
<span>于&nbsp;</span><time datetime="2022-06-12 00:00:00 +0000 UTC" data-pagefind-meta=日期>2022年6月12日</time>
<span>发布在&nbsp;</span><ul class=categories><li><a data-pagefind-filter=分类 href=/categories/using/>Using</a></li></ul></div><h2 id=提出问题>提出问题</h2><p>Git 支持三种远程访问协议，分别是：SSH、HTTP/HTTPS 以及 git 协议。国内的 GitHub 用户通常会选择使用 HTTPS 协议，主要原因是该协议可以通过 HTTP 代理服务器来访问 GitHub。</p><p>使用 HTTPS 协议的不便之处在于每次请求都需要提供用户名和密码。因此，Git 通过一个用户凭证管理系统来解决这个问题，这个系统称作 Git Credentials。通过这个系统，Git 可以实现存储和查询用户凭证。</p><p>对普通用户来说，无论你是使用命令行，还是 Sourcetree 或 TortoiseGit 之类的 GUI 工具，只要在 Git 弹出的对话框里输入用户名和密码（Personal Access Token）就可以完成身份验证了。Git 会自动记住账号，下次便无需再次输入（在某些配置环境下，Git 不会记住密码，需要每次手动输入用户名密码）。这一切看起来都简单得理所当然。</p><p>不过，一旦当我们需要同时管理多个属于不同 GitHub 账号的 repo 时，情况就变得复杂起来。某些情况下，Git 会使用之前记住的用户凭证来登录不同的 GitHub 账号。这样自然也就无法完成身份验证了。</p><p>那么，<strong>如何才能做到不同的 repo 使用不同的 GitHub 账号呢</strong>？在解答这个问题之前，首先要了解 Git 是如何管理用户凭证的。</p><h2 id=凭证存储>凭证存储</h2><p>Git credentials 支持不同的 backend，以实现不同的凭证存储方式。这些 backend 被称作 <strong>credential helper</strong>，中文姑且翻译为助手。通过 <code>git config credential.helper</code> 命令可以查询当前使用的助手。Git credentials 常见的助手有：</p><ul><li>cache<br>将用户凭证存储在内存中，而不保存到磁盘，并且可以设置过期时间。</li><li>store<br>将用户凭证以明文的形式存储在文件中。默认保存在 <code>~/.git-credentials</code> 文件。</li><li>wincred<br>将用户凭证存储到 Windows 的凭据管理器中。</li><li>osxkeychain<br>类似于 wincred。将用户凭证存储到 macOS 当前用户的钥匙串中。</li><li>manager-core<br>由第三方工具 Git Credential Manager 提供的 credential helper。该工具前身是 Git Credential Manager for Windows，仅支持 Windows 平台。现在的 GCM 已经支持跨平台。</li></ul><h2 id=设置>设置</h2><p>为当前仓库指定 credential helper：</p><pre><code class=language-powershell>git config credential.helper store</code></pre><p>等同于在 repo 的 <code>.git/config</code> 中配置：</p><pre><code class=language-ini>[credential]
help = store</code></pre><p>还可以为助手指定参数：</p><pre><code class=language-powershell>git config credential.helper &#39;store --file ~/.my-credentials&#39;</code></pre><p>等同于在 repo 的 <code>.git/config</code> 中配置：</p><pre><code class=language-ini>[credential]
help = store --file ~/.my-credentials</code></pre><p>定义凭证使用的用户名：</p><pre><code class=language-powershell>git config credential.username fournoas</code></pre><p>等同于在 repo 的 <code>.git/config</code> 中配置：</p><pre><code class=language-ini>[credential]
username = fournoas</code></pre><p>此外，可以为凭证指定一个由 URL 定义的上下文。只有当请求 URL 匹配这个上下文，才会使用此凭证。</p><pre><code class=language-powershell>git config credential.https://github.com.helper wincred</code></pre><p>等同于在 repo 的 <code>.git/config</code> 中配置：</p><pre><code class=language-ini>[credential &#34;https://github.com&#34;]
help = wincred</code></pre><h2 id=请求凭证>请求凭证</h2><p>Git 通过 <code>git credential</code> 命令来访问凭证。</p><pre><code class=language-plaintext>usage: git credential (fill|approve|reject)</code></pre><p>该命令接受三个参数：</p><ul><li><code>fill</code> 读取符合条件的凭证</li><li><code>approve</code> 写入凭证</li><li><code>reject</code> 清除符合条件的凭证</li></ul><p>此处假设我们需要读取 GitHub 上用户名为 fournoas 的用户凭证。运行命令 <code>git credential fill</code>，这是一个交互式的命令，运行后会等待用户输入筛选条件，每行输入定义一个条件，格式为 <code>key=value</code>，输入空行提交查询。支持的查询关键字有：</p><ul><li>protocol</li><li>host</li><li>path</li><li>username</li><li>url</li></ul><p>下面是一个查询成功返回的样例：</p><pre><code class=language-plaintext>protocol=https
host=github.com
username=fournoas

protocol=https
host=github.com
username=fournoas
password=xxxxxxxxxxxx</code></pre><p>空行前是查询参数，空行后是返回的查询结果。如果助手中储存了多条符合条件的记录，也仅返回一条。</p><h2 id=自定义助手>自定义助手</h2><p>我们可以通过以下命令直接访问助手：</p><ul><li><code>git credential-cache</code></li><li><code>git credential-store</code></li><li><code>git credential-wincred</code></li><li><code>git credential-manager-core</code></li></ul><p>之前配置的 <code>credential.helper</code> 最终也是执行相应的命令。下表展示了配置所支持的值和对应的行为：</p><table><thead><tr><th>配置值</th><th>行为</th></tr></thead><tbody><tr><td><code>foo</code></td><td>执行 <code>git-credential-foo</code></td></tr><tr><td><code>foo -a --opt=bcd</code></td><td>执行 <code>git-credential-foo -a --opt=bcd</code></td></tr><tr><td><code>/absolute/path/foo -xyz</code></td><td>执行 <code>/absolute/path/foo -xyz</code></td></tr><tr><td><code>!f() { echo "password=s3cre7"; }; f</code></td><td><code>!</code> 后面的代码会在 shell 执行</td></tr></tbody></table><p>按照此原理，我们也可以自己实现自定义的助手命令。</p><p>助手命令需要接受一个 action 参数，通常格式为 <code>git-credential-foo [options] &lt;action></code>。</p><ul><li><code>get</code> 从助手中获取符合条件的凭证；</li><li><code>store</code> 将凭证保存到助手中；</li><li><code>erase</code> 将符合条件的凭证从助手中清除。</li></ul><p>这三个 action 和 <code>git credential</code> 的三个参数相对应，接口格式也一致。下面是官方文档给出的一个 Ruby 实现：</p><pre><code class=language-ruby>#!/usr/bin/env ruby

require &#39;optparse&#39;

path = File.expand_path &#39;~/.git-credentials&#39;
OptionParser.new do |opts|
    opts.banner = &#39;USAGE: git-credential-read-only [options] &lt;action&gt;&#39;
    opts.on(&#39;-f&#39;, &#39;--file PATH&#39;, &#39;Specify path for backing store&#39;) do |argpath|
        path = File.expand_path argpath
    end
end.parse!

exit(0) unless ARGV[0].downcase == &#39;get&#39;
exit(0) unless File.exists? path

known = {}
while line = STDIN.gets
    break if line.strip == &#39;&#39;
    k,v = line.strip.split &#39;=&#39;, 2
    known[k] = v
end

File.readlines(path).each do |fileline|
    prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first
    if prot == known[&#39;protocol&#39;] and host == known[&#39;host&#39;] and user == known[&#39;username&#39;] then
        puts &#34;protocol=#{prot}&#34;
        puts &#34;host=#{host}&#34;
        puts &#34;username=#{user}&#34;
        puts &#34;password=#{pass}&#34;
        exit(0)
    end
end</code></pre><p>将代码保存为 <code>git-credential-read-only</code>，放到 PATH 路径下并给予执行权限。配置 Git 使用这个自定义助手：</p><pre><code class=language-powershell>git config credential.helper &#39;read-only --file /mnt/shared/creds&#39;</code></pre><h2 id=给出答案>给出答案</h2><p>之所以会产生本文开头的问题，是因为 Git 默认使用 protocol 和 host 两个参数来获取用户凭证。只要是 <a href=https://github.com target=_blank rel=noopener>https://github.com</a> 下的 repo，都会使用相同的用户凭证。解决方法就是让 Git 在请求用户凭证的时候带上 username 参数，这样就能区分开不同的 GitHub 账号了。有两个方法可以用来指定 repo 的用户名：</p><p>方法1：在 repo 的 origin url 中指定用户名</p><pre><code class=language-powershell>git remote set-url origin https://&lt;username&gt;@github.com/&lt;username&gt;/&lt;repo name&gt;</code></pre><p>方法2：在 repo 的 credential 中指定用户名</p><pre><code class=language-powershell>git config credential.username &lt;username&gt;</code></pre></div><div class=taxonomy data-pagefind-ignore><div class=taxonomy-tags><ul class=tags><li>#<a data-pagefind-filter=标签 href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li><li>#<a data-pagefind-filter=标签 href=/tags/Git/>Git</a></li></ul></div></div><div class=pagination data-pagefind-ignore><a href=/posts/how-to-fix-failed-to-load-jvm-dll-error/ class="left arrow">上一篇：<br>如何修复 Failed to load JVM DLL 错误</a>
<a href=/posts/scoop-installer-issues/ class="right arrow">下一篇：<br>Scoop 踩坑记录</a>
<a href=# class=top>返回顶部</a></div></main><script src=/js/page.js></script>
<script src=/js/main.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/scala.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/nim.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/powershell.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/nginx.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=/js/code.js></script>
<script>hljs.highlightAll(),hljs.initLineNumbersOnLoad(),hljs.initSelectLines()</script><footer><span>&copy; <time datetime="2023-07-31 02:24:28.004737353 +0000 UTC m=+0.246547246">2023</time> fournoas.com. Powered by <a href=https://gohugo.io>Hugo</a>.</span></footer></body></html>