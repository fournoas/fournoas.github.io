<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>一个语言的诞生（Act I） &middot; 白汤四物</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/rainbow.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/scala.min.js crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/nim.min.js crossorigin=anonymous></script><script>hljs.initHighlightingOnLoad();</script><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href rel=alternate type=application/rss+xml title=白汤四物><script async src="https://www.googletagmanager.com/gtag/js?id=UA-153840298-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-153840298-1');</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main><div class=post><h1 class=post-title>一个语言的诞生（Act I）</h1><div class=post-line></div><div class=post-info><span>作者</span>
Fournoas
<span>于&nbsp;</span><time datetime="2015-07-11 00:00:00 &#43;0000 UTC">2015年7月11日</time>
<span>发布在</span><ul class=categories><li><a href=https://www.fournoas.com/categories/coding/>Coding</a></li></ul></div><h1 id=第一幕-哈希表>第一幕 哈希表</h1><p>哈希表是动态脚本语言的基石。动态语言中，全局变量表、全局字符串表、对象虚函数表、元数据表皆为哈希表。欲实现语言，则必先实现哈希表。</p><p>哈希表原理很简单，不再赘述。不同语言实现的哈希表主要区别在于处理碰撞的机制不同。一种叫“Separate chaining”，PHP的哈希表使用了这种方式；另一种叫“Open addressing”，Lua的哈希表使用的是这种。前者发生碰撞会创建一个新的bucket，然后用链表将所有碰撞的bucket链接起来；而后者在现有的buckets中找到一个空的bucket来存放发生碰撞的key-value pair。我选择的是后一种方式，一方面是节约内存，另一方面还能节省GC开销。</p><p>哈希表初始大小为8，也就是哈希表包含8个buckets。考虑到取余是一个比较耗CPU的操作，所以哈希表大小以2的指数倍增长，这样可以用位移的方式来取余。</p><p>key值可以是任何可哈希的对象，比如字符串、整数、浮点数、元组。本来觉得所有引用对象将地址作为哈希值也可以作为key，后来一想不对——因为GC采用的是Mark-Compact算法，每次GC后对象的地址可能是不同的。考虑是不是要在对象数据结构里增加一个唯一ID域。</p><p>另外有个问题就是“hash collision DoS vulnerability”。就是恶意构造N多HASH值一样的字符串提交，把哈希表变成了链表。PHP的解决方案是限制用户提交参数的个数，Lua的解决方案是增加一个随机的seed。Lua的解决方案是最完美的，不过采用seed是有成本的，而且考虑到今后的RPC调用，想要hash复用就不行了。最后还是采用类型PHP的方案，接受用户外部数据的时候做下限制就可以了。</p><p>补充：
哈希表的键类型选择纠结了很久。一般来说，任何实现哈希表的语言中字符串类型或整型都可以作为key，而其他类型是否允许作为key就没有个统一标准了。比如C#对象有提供GetHashCode方法用于计算散列，所以字典的键支持所有的类型。Python和Lua中使用对象的内存地址作为哈希值。</p><p>再补充：
最后决定在Object头部添加一个hash值域。该值迟计算，当第一次请求获取对象哈希值时根据对象地址求得哈希值，之后该对象就一直使用该值，无论对象地址是否改变。</p></div><div class=taxonomy><div class=taxonomy-series><span>系列：</span><ul class=series><li><a href=https://www.fournoas.com/series/%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%9E%E7%94%9F/>一个语言的诞生</a></li></ul></div></div><div class=pagination><a href=/posts/the-birth-of-a-language-prologue/ class="left arrow">上一篇：<br>一个语言的诞生（Prologue）</a>
<a href=/posts/the-birth-of-a-language-2/ class="right arrow">下一篇：<br>一个语言的诞生（Act II）</a>
<a href=# class=top>返回顶部</a></div></main><footer><span>&copy; <time datetime="2021-06-13 11:37:25.355922411 &#43;0000 UTC m=&#43;0.343019449">2021</time> fournoas.com. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/EmielH/tale-hugo>Tale</a> theme.</span></footer><script src=/js/main.js></script></body></html>