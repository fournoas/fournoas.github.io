<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>MSN 双开工具源代码 &#183; 白汤四物</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/fontawesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/solid.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=//cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/fontawesome.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/solid.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/rainbow.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/scala.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/nim.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/powershell.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/nginx.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js></script>
<script>hljs.highlightAll(),hljs.initLineNumbersOnLoad()</script><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href rel=alternate type=application/rss+xml title=白汤四物><script async src="https://www.googletagmanager.com/gtag/js?id=UA-153840298-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-153840298-1")</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/search/><span>搜索</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main data-pagefind-body><div class=post><h1 class=post-title data-pagefind-meta=title>MSN 双开工具源代码</h1><div class=post-line></div><div class=post-info><span>作者</span>
<span data-pagefind-meta=作者>Fournoas</span>
<span>于&nbsp;</span><time datetime="2006-02-04 00:00:00 +0000 UTC" data-pagefind-meta=日期>2006年2月4日</time>
<span>发布在&nbsp;</span><ul class=categories><li><a data-pagefind-filter=分类 href=https://www.fournoas.com/categories/coding/>Coding</a></li></ul></div><blockquote><p>网上偶然拾得本人于 2006 年所写的 <strong>MSN Messenger</strong> 双/多开工具的源代码。此即时通讯软件早于 2013 年便已停止服务，而今再看昔日所写代码不甚感慨，遂记录于此，以兹纪念。</p><p>2021年5月17日</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#pragma comment(linker,&#34;/subsystem:windows&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#pragma comment(linker,&#34;/align:4096&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MSN_APP &#34;\\MSN Messenger\\msnmsgr.exe&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TF_BIT	0x100
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>map <span style=color:#f92672>&lt;</span>DWORD, HANDLE<span style=color:#f92672>&gt;</span>	ThreadList;
</span></span><span style=display:flex><span>HANDLE			hTargetProcess;
</span></span><span style=display:flex><span>DWORD			dwMainThreadId;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DWORD <span style=color:#a6e22e>GetRetAddress</span>( LPVOID lpBsp )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	DWORD dwBytesRead, dwRetAddress;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> ( ReadProcessMemory( hTargetProcess, lpBsp, <span style=color:#f92672>&amp;</span>dwRetAddress, <span style=color:#66d9ef>sizeof</span>(DWORD), <span style=color:#f92672>&amp;</span>dwBytesRead ) )
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>(dwRetAddress);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>(NULL);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LPVOID g_lpGetLastErrorRet;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SetHook</span>( <span style=color:#66d9ef>bool</span> bSet )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span>	bInitial;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> LPVOID	lpGetLastErrorRet;
</span></span><span style=display:flex><span>	BYTE		bytOriginalOpCode <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xC3</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>bInitial )
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		BYTE	lpCode[<span style=color:#ae81ff>32</span>];
</span></span><span style=display:flex><span>		LPVOID	lpGetLastError;
</span></span><span style=display:flex><span>		lpGetLastError <span style=color:#f92672>=</span> GetProcAddress( GetModuleHandle( <span style=color:#e6db74>&#34;kernel32.dll&#34;</span> ), <span style=color:#e6db74>&#34;GetLastError&#34;</span> );
</span></span><span style=display:flex><span>		DWORD dwBytesRead;
</span></span><span style=display:flex><span><span style=color:#75715e>/* ReadProcessMemory(hTargetProcess,lpGetLastError,&amp;bytOriginalOpCode,sizeof(BYTE),&amp;dwBytesRead); */</span>
</span></span><span style=display:flex><span>		ReadProcessMemory( hTargetProcess, lpGetLastError, <span style=color:#f92672>&amp;</span>lpCode, <span style=color:#66d9ef>sizeof</span>(lpCode), <span style=color:#f92672>&amp;</span>dwBytesRead );
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> ( <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>32</span>; i<span style=color:#f92672>++</span> )
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> ( <span style=color:#ae81ff>0xC3</span> <span style=color:#f92672>==</span> lpCode[i] )
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				g_lpGetLastErrorRet <span style=color:#f92672>=</span> lpGetLastErrorRet <span style=color:#f92672>=</span> (LPVOID) ( ( (DWORD) lpGetLastError) <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		bInitial <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	BYTE				bytBreakOpCode <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xCC</span>;
</span></span><span style=display:flex><span>	DWORD				dwBytesReadWrite;
</span></span><span style=display:flex><span>	MEMORY_BASIC_INFORMATION	mbi;
</span></span><span style=display:flex><span>	VirtualQueryEx( hTargetProcess, lpGetLastErrorRet, <span style=color:#f92672>&amp;</span>mbi, <span style=color:#66d9ef>sizeof</span>(mbi) );
</span></span><span style=display:flex><span>	VirtualProtectEx( hTargetProcess, mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, <span style=color:#f92672>&amp;</span>mbi.Protect );
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> ( bSet )
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		WriteProcessMemory( hTargetProcess, lpGetLastErrorRet, <span style=color:#f92672>&amp;</span>bytBreakOpCode, <span style=color:#66d9ef>sizeof</span>(BYTE), <span style=color:#f92672>&amp;</span>dwBytesReadWrite );
</span></span><span style=display:flex><span>	}<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>		WriteProcessMemory( hTargetProcess, lpGetLastErrorRet, <span style=color:#f92672>&amp;</span>bytOriginalOpCode, <span style=color:#66d9ef>sizeof</span>(BYTE), <span style=color:#f92672>&amp;</span>dwBytesReadWrite );
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	FlushInstructionCache( hTargetProcess, lpGetLastErrorRet, <span style=color:#66d9ef>sizeof</span>(BYTE) );
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>(TRUE);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> WINAPI <span style=color:#a6e22e>WinMain</span>( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span style=color:#66d9ef>int</span> nCmdShow )
</span></span><span style=display:flex><span><span style=color:#75715e>/* int main() */</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span>			lpApplication[MAX_PATH];
</span></span><span style=display:flex><span>	STARTUPINFO		si;
</span></span><span style=display:flex><span>	PROCESS_INFORMATION	pi;
</span></span><span style=display:flex><span>	ZeroMemory( <span style=color:#f92672>&amp;</span>si, <span style=color:#66d9ef>sizeof</span>(si) );
</span></span><span style=display:flex><span>	ZeroMemory( <span style=color:#f92672>&amp;</span>pi, <span style=color:#66d9ef>sizeof</span>(pi) );
</span></span><span style=display:flex><span>	si.cb <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(si);
</span></span><span style=display:flex><span>	GetEnvironmentVariable( <span style=color:#e6db74>&#34;ProgramFiles&#34;</span>, lpApplication, MAX_PATH );
</span></span><span style=display:flex><span>	strcat( lpApplication, MSN_APP );
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>CreateProcess( lpApplication, NULL, NULL, NULL, FALSE, DEBUG_ONLY_THIS_PROCESS, NULL, NULL, <span style=color:#f92672>&amp;</span>si, <span style=color:#f92672>&amp;</span>pi ) )
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		MessageBox( GetDesktopWindow(), <span style=color:#e6db74>&#34;Fail to launch </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>msnmsgr.exe</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>!&#34;</span>, <span style=color:#e6db74>&#34;Error&#34;</span>, MB_OK <span style=color:#f92672>|</span> MB_ICONSTOP );
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>(FALSE);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	DEBUG_EVENT	de;
</span></span><span style=display:flex><span>	BOOL		bContinue <span style=color:#f92672>=</span> TRUE, bInitial <span style=color:#f92672>=</span> FALSE;
</span></span><span style=display:flex><span>	DWORD		dwContinueStatus;
</span></span><span style=display:flex><span>	CONTEXT		context;
</span></span><span style=display:flex><span>	ZeroMemory( <span style=color:#f92672>&amp;</span>context, <span style=color:#66d9ef>sizeof</span>(context) );
</span></span><span style=display:flex><span>	UINT uHookCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> ( bContinue )
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		bContinue		<span style=color:#f92672>=</span> WaitForDebugEvent( <span style=color:#f92672>&amp;</span>de, INFINITE );
</span></span><span style=display:flex><span>		dwContinueStatus	<span style=color:#f92672>=</span> DBG_CONTINUE;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> ( de.dwDebugEventCode )
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> CREATE_THREAD_DEBUG_EVENT:
</span></span><span style=display:flex><span>			ThreadList[de.dwThreadId] <span style=color:#f92672>=</span> de.u.CreateThread.hThread;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> CREATE_PROCESS_DEBUG_EVENT:
</span></span><span style=display:flex><span>			hTargetProcess			<span style=color:#f92672>=</span> de.u.CreateProcessInfo.hProcess;
</span></span><span style=display:flex><span>			ThreadList[de.dwThreadId]	<span style=color:#f92672>=</span> de.u.CreateProcessInfo.hThread;
</span></span><span style=display:flex><span>			dwMainThreadId			<span style=color:#f92672>=</span> de.dwThreadId;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> EXIT_PROCESS_DEBUG_EVENT:
</span></span><span style=display:flex><span>			bContinue <span style=color:#f92672>=</span> FALSE;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> EXCEPTION_DEBUG_EVENT:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>switch</span> ( de.u.Exception.ExceptionRecord.ExceptionCode )
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> EXCEPTION_SINGLE_STEP:
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> ( uHookCount <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> )
</span></span><span style=display:flex><span>				{
</span></span><span style=display:flex><span>					context.ContextFlags <span style=color:#f92672>=</span> CONTEXT_FULL;
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> ( GetThreadContext( ThreadList[de.dwThreadId], <span style=color:#f92672>&amp;</span>context ) )
</span></span><span style=display:flex><span>					{
</span></span><span style=display:flex><span>						SetHook( TRUE );
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> EXCEPTION_BREAKPOINT:
</span></span><span style=display:flex><span>				dwContinueStatus <span style=color:#f92672>=</span> de.u.Exception.dwFirstChance <span style=color:#f92672>?</span> DBG_CONTINUE : DBG_EXCEPTION_NOT_HANDLED;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>bInitial )
</span></span><span style=display:flex><span>				{
</span></span><span style=display:flex><span>					SetHook( TRUE );
</span></span><span style=display:flex><span>					bInitial <span style=color:#f92672>=</span> TRUE;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				context.ContextFlags <span style=color:#f92672>=</span> CONTEXT_FULL;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> ( GetThreadContext( ThreadList[de.dwThreadId], <span style=color:#f92672>&amp;</span>context ) )
</span></span><span style=display:flex><span>				{
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> ( (context.Eip <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> (DWORD) g_lpGetLastErrorRet )
</span></span><span style=display:flex><span>					{
</span></span><span style=display:flex><span><span style=color:#75715e>/* printf(&#34;Return Address: 0x%08X\n&#34;,GetRetAddress((LPVOID)context.Esp)); */</span>
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>if</span> ( <span style=color:#ae81ff>0x00700000</span> <span style=color:#f92672>&gt;</span> GetRetAddress( (LPVOID) context.Esp ) <span style=color:#f92672>&amp;&amp;</span> de.dwThreadId <span style=color:#f92672>==</span> dwMainThreadId )
</span></span><span style=display:flex><span>						{
</span></span><span style=display:flex><span>							<span style=color:#66d9ef>if</span> ( ERROR_ALREADY_EXISTS <span style=color:#f92672>==</span> context.Eax )
</span></span><span style=display:flex><span>							{
</span></span><span style=display:flex><span>								context.Eax <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>								uHookCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>							}
</span></span><span style=display:flex><span>						}
</span></span><span style=display:flex><span>						SetHook( FALSE );
</span></span><span style=display:flex><span>						context.Eip<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>						context.EFlags <span style=color:#f92672>|=</span> TF_BIT;
</span></span><span style=display:flex><span>						SetThreadContext( ThreadList[de.dwThreadId], <span style=color:#f92672>&amp;</span>context );
</span></span><span style=display:flex><span>						dwContinueStatus <span style=color:#f92672>=</span> DBG_CONTINUE;
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> dwContinueStatus <span style=color:#f92672>=</span> DBG_EXCEPTION_NOT_HANDLED;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>/* default: */</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		ContinueDebugEvent( de.dwProcessId, de.dwThreadId, dwContinueStatus );
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	CloseHandle( pi.hProcess );
</span></span><span style=display:flex><span>	CloseHandle( pi.hThread );
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>(TRUE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>MSN Messenger 通过创建全局互斥量来保证系统中同时只能运行一个进程。伪代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>hMutex <span style=color:#f92672>=</span> CreateMutex(NULL, FALSE, <span style=color:#e6db74>&#34;MSNMessengerIsRunning&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (GetLastError() <span style=color:#f92672>==</span> ERROR_ALREADY_EXISTS) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>     <span style=color:#75715e>// MSN Messenger 已启动，本进程即将退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     ExitProcess();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>工具的破解原理是：通过 Hook <code>GetLastError</code>，修改该 API 的返回值，从而欺骗 MSN 进程，以绕过限制。</p><script src=/js/post.js></script></div><div class=taxonomy data-pagefind-ignore><div class=taxonomy-tags><ul class=tags><li>#<a data-pagefind-filter=标签 href=https://www.fournoas.com/tags/C/C++/>C/C++</a></li></ul></div></div><div class=pagination data-pagefind-ignore><a href=/about/ class="left arrow">上一篇：<br>关于</a>
<a href=/posts/the-giving-plague/ class="right arrow">下一篇：<br>赐予的瘟疫</a>
<a href=# class=top>返回顶部</a></div></main><footer><span>&copy; <time datetime="2022-11-03 07:21:10.799143133 +0000 UTC m=+0.264410320">2022</time> fournoas.com. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/EmielH/tale-hugo>Tale</a> theme.</span></footer><script src=/js/main.js></script></body></html>