<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Python 的 signal 处理与 print() 的 reentrant call 运行时错误 &#183; 白汤四物</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/fontawesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/solid.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/fontawesome.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/solid.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/rainbow.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/scala.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/nim.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/powershell.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/nginx.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=/js/code.js></script>
<script>hljs.highlightAll(),hljs.initLineNumbersOnLoad(),hljs.initSelectLines()</script><link href rel=alternate type=application/rss+xml title=白汤四物><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-153840298-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-153840298-1")</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/search/><span>搜索</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main data-pagefind-body><div class=post><h1 class=post-title data-pagefind-meta=title>Python 的 signal 处理与 print() 的 reentrant call 运行时错误</h1><div class=post-line></div><div class=post-info><span>作者</span>
<span data-pagefind-meta=作者>Fournoas</span>
<span>于&nbsp;</span><time datetime="2022-10-31 00:00:00 +0000 UTC" data-pagefind-meta=日期>2022年10月31日</time>
<span>发布在&nbsp;</span><ul class=categories><li><a data-pagefind-filter=分类 href=https://www.fournoas.com/categories/coding/>Coding</a></li></ul></div><p>在前文《<a href=../why-does-ctrl-c-not-kill-python-process-in-windows-console/>为何 Windows 下无法用 Ctrl+C 终止 Python 进程</a>》中，讲解了 Python 信号处理的基本原理。当时为了撰写文章而编写了一些测试代码，在运行某例测试代码时，发生了奇怪的 reentrant call 运行时错误。代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> signal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGINT, <span style=color:#66d9ef>lambda</span> signum, frame: print(<span style=color:#e6db74>&#39;test&#39;</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>: print(<span style=color:#e6db74>&#39;test&#39;</span>)
</span></span></code></pre></div><p>在程序运行中按下 Ctrl+C，程序抛出 RuntimeError 异常。完整错误信息如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;test.py&#34;, line 4, in &lt;module&gt;
</span></span><span style=display:flex><span>    while True: print(&#39;test&#39;)
</span></span><span style=display:flex><span>                ^^^^^^^^^^^^^
</span></span><span style=display:flex><span>  File &#34;test.py&#34;, line 3, in &lt;lambda&gt;
</span></span><span style=display:flex><span>    signal.signal(signal.SIGINT, lambda signum, frame: print(&#39;test&#39;))
</span></span><span style=display:flex><span>                                                       ^^^^^^^^^^^^^
</span></span><span style=display:flex><span>RuntimeError: reentrant call inside &lt;_io.BufferedWriter name=&#39;&lt;stdout&gt;&#39;&gt;
</span></span></code></pre></div><p>错误信息中所提到的 reentrant call 是一个计算机术语，它的意思是程序或者子例程（subroutine）在执行过程中被中断，此时再次调用该程序或者子例程。由于 Python 的信号处理器是运行在主线程中，所以不存在多线程冲突的可能。因此，猜想错误可能是由如下的代码引起的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>entrant_status <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print</span>(text):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (entrant_status <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>RuntimeError</span>(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;reentrant call inside &lt;_io.BufferedWriter name=&#39;&lt;stdout&gt;&#39;&gt;&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    entrant_status <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    此时因按下 Ctrl+C 而产生软中断
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Python 中止执行此处代码
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    转而调用 signal_handler()
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>    signal_handler(signum, frame)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    entrant_status <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>signal_handler</span>(signum, frame):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;test&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#39;test&#39;</span>)
</span></span></code></pre></div><p>但是根据 Python 官方文档的描述，Python VM 是在两条 bytecode 指令之间调用信号处理器的。而 <code>print()</code> 属于 builtin function，调用 <code>print()</code> 只需要一条 <code>CALL_FUNCTION</code> 指令。那么唯一的可能就是，官方文档的描述并不准确，Python 还有其他唤起信号处理器的方式。看来只能从 Python 源代码中去寻找答案了。</p><p>根据错误提示，在 Python 的源代码中搜索「<a href="https://github.com/python/cpython/search?l=C&q=reentrant+call+inside">reentrant call inside</a>」，发现 <a href=https://github.com/python/cpython/blob/774ef28814d0d9d57ec813cb31b0a7af6c476127/Modules/_io/bufferedio.c>Modules/_io/bufferedio.c</a> 文件的<a href=https://github.com/python/cpython/blob/774ef28814d0d9d57ec813cb31b0a7af6c476127/Modules/_io/bufferedio.c#L262>第 262 行</a>高度疑似为抛出异常的代码。此处附近完整的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code data-ln-selected=262 data-ln-start-from=255 class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_enter_buffered_busy</span>(buffered <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> relax_locking;
</span></span><span style=display:flex><span>    PyLockStatus st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (self<span style=color:#f92672>-&gt;</span>owner <span style=color:#f92672>==</span> PyThread_get_thread_ident()) {
</span></span><span style=display:flex><span>        PyErr_Format(PyExc_RuntimeError,
</span></span><span style=display:flex><span>                     <span style=color:#e6db74>&#34;reentrant call inside %R&#34;</span>, self);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    relax_locking <span style=color:#f92672>=</span> _Py_IsFinalizing();
</span></span><span style=display:flex><span>    Py_BEGIN_ALLOW_THREADS
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>relax_locking)
</span></span><span style=display:flex><span>        st <span style=color:#f92672>=</span> PyThread_acquire_lock(self<span style=color:#f92672>-&gt;</span>lock, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* When finalizing, we don&#39;t want a deadlock to happen with daemon
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * threads abruptly shut down while they owned the lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Therefore, only wait for a grace period (1 s.).
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Note that non-daemon threads have already exited here, so this
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * shouldn&#39;t affect carefully written threaded I/O code.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        st <span style=color:#f92672>=</span> PyThread_acquire_lock_timed(self<span style=color:#f92672>-&gt;</span>lock, (PY_TIMEOUT_T)<span style=color:#ae81ff>1e6</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Py_END_ALLOW_THREADS
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (relax_locking <span style=color:#f92672>&amp;&amp;</span> st <span style=color:#f92672>!=</span> PY_LOCK_ACQUIRED) {
</span></span><span style=display:flex><span>        PyObject <span style=color:#f92672>*</span>ascii <span style=color:#f92672>=</span> PyObject_ASCII((PyObject<span style=color:#f92672>*</span>)self);
</span></span><span style=display:flex><span>        _Py_FatalErrorFormat(__func__,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;could not acquire lock for %s at interpreter &#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;shutdown, possibly due to daemon threads&#34;</span>,
</span></span><span style=display:flex><span>            ascii <span style=color:#f92672>?</span> PyUnicode_AsUTF8(ascii) <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&lt;ascii(self) failed&gt;&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ENTER_BUFFERED(self) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    ( (PyThread_acquire_lock(self-&gt;lock, 0) ? \
</span></span></span><span style=display:flex><span><span style=color:#75715e>       1 : _enter_buffered_busy(self)) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>     &amp;&amp; (self-&gt;owner = PyThread_get_thread_ident(), 1) )
</span></span></span></code></pre></div><p>RuntimeError 是在 <code>_enter_buffered_busy</code> 函数中被抛出的，而该函数被 <code>ENTER_BUFFERED</code> 宏所调用：当使用 <code>PyThread_acquire_lock()</code> 获取锁失败时便会抛出异常。进一步在当前文件中搜索<code>ENTER_BUFFERED</code>，发现<a href=https://github.com/python/cpython/blob/774ef28814d0d9d57ec813cb31b0a7af6c476127/Modules/_io/bufferedio.c#L1916>第 1916 行</a>处的调用可能是抛出异常的上层函数，该函数名为 <code>io_BufferedWriter_write_impl</code>，正好和错误信息中的 <code>&lt;_io.BufferedWriter name='&lt;stdout>'></code> 相对应。该函数的完整代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*[clinic input]
</span></span></span><span style=display:flex><span><span style=color:#75715e>_io.BufferedWriter.write
</span></span></span><span style=display:flex><span><span style=color:#75715e>    buffer: Py_buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e>    /
</span></span></span><span style=display:flex><span><span style=color:#75715e>[clinic start generated code]*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_io_BufferedWriter_write_impl</span>(buffered <span style=color:#f92672>*</span>self, Py_buffer <span style=color:#f92672>*</span>buffer)
</span></span><span style=display:flex><span><span style=color:#75715e>/*[clinic end generated code: output=7f8d1365759bfc6b input=dd87dd85fc7f8850]*/</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>res <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    Py_ssize_t written, avail, remaining;
</span></span><span style=display:flex><span>    Py_off_t offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CHECK_INITIALIZED(self)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ENTER_BUFFERED(self))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Issue #31976: Check for closed file after acquiring the lock. Another
</span></span></span><span style=display:flex><span><span style=color:#75715e>       thread could be holding the lock while closing the file. */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (IS_CLOSED(self)) {
</span></span><span style=display:flex><span>        PyErr_SetString(PyExc_ValueError, <span style=color:#e6db74>&#34;write to closed file&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Fast path: the data to write can be fully buffered. */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>VALID_READ_BUFFER(self) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>VALID_WRITE_BUFFER(self)) {
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>raw_pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    avail <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(self<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>-</span> self<span style=color:#f92672>-&gt;</span>pos, Py_off_t, Py_ssize_t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buffer<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>&lt;=</span> avail) {
</span></span><span style=display:flex><span>        memcpy(self<span style=color:#f92672>-&gt;</span>buffer <span style=color:#f92672>+</span> self<span style=color:#f92672>-&gt;</span>pos, buffer<span style=color:#f92672>-&gt;</span>buf, buffer<span style=color:#f92672>-&gt;</span>len);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>VALID_WRITE_BUFFER(self) <span style=color:#f92672>||</span> self<span style=color:#f92672>-&gt;</span>write_pos <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>-&gt;</span>pos) {
</span></span><span style=display:flex><span>            self<span style=color:#f92672>-&gt;</span>write_pos <span style=color:#f92672>=</span> self<span style=color:#f92672>-&gt;</span>pos;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ADJUST_POSITION(self, self<span style=color:#f92672>-&gt;</span>pos <span style=color:#f92672>+</span> buffer<span style=color:#f92672>-&gt;</span>len);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (self<span style=color:#f92672>-&gt;</span>pos <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>-&gt;</span>write_end)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>-&gt;</span>write_end <span style=color:#f92672>=</span> self<span style=color:#f92672>-&gt;</span>pos;
</span></span><span style=display:flex><span>        written <span style=color:#f92672>=</span> buffer<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First write the current buffer */</span>
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> _bufferedwriter_flush_unlocked(self);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (res <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        Py_ssize_t <span style=color:#f92672>*</span>w <span style=color:#f92672>=</span> _buffered_check_blocking_error();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (w <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (self<span style=color:#f92672>-&gt;</span>readable)
</span></span><span style=display:flex><span>            _bufferedreader_reset_buf(self);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Make some place by shifting the buffer. */</span>
</span></span><span style=display:flex><span>        assert(VALID_WRITE_BUFFER(self));
</span></span><span style=display:flex><span>        memmove(self<span style=color:#f92672>-&gt;</span>buffer, self<span style=color:#f92672>-&gt;</span>buffer <span style=color:#f92672>+</span> self<span style=color:#f92672>-&gt;</span>write_pos,
</span></span><span style=display:flex><span>                Py_SAFE_DOWNCAST(self<span style=color:#f92672>-&gt;</span>write_end <span style=color:#f92672>-</span> self<span style=color:#f92672>-&gt;</span>write_pos,
</span></span><span style=display:flex><span>                                 Py_off_t, Py_ssize_t));
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>write_end <span style=color:#f92672>-=</span> self<span style=color:#f92672>-&gt;</span>write_pos;
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>raw_pos <span style=color:#f92672>-=</span> self<span style=color:#f92672>-&gt;</span>write_pos;
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>pos <span style=color:#f92672>-=</span> self<span style=color:#f92672>-&gt;</span>write_pos;
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>write_pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        avail <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(self<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>-</span> self<span style=color:#f92672>-&gt;</span>write_end,
</span></span><span style=display:flex><span>                                 Py_off_t, Py_ssize_t);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (buffer<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>&lt;=</span> avail) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* Everything can be buffered */</span>
</span></span><span style=display:flex><span>            PyErr_Clear();
</span></span><span style=display:flex><span>            memcpy(self<span style=color:#f92672>-&gt;</span>buffer <span style=color:#f92672>+</span> self<span style=color:#f92672>-&gt;</span>write_end, buffer<span style=color:#f92672>-&gt;</span>buf, buffer<span style=color:#f92672>-&gt;</span>len);
</span></span><span style=display:flex><span>            self<span style=color:#f92672>-&gt;</span>write_end <span style=color:#f92672>+=</span> buffer<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>            self<span style=color:#f92672>-&gt;</span>pos <span style=color:#f92672>+=</span> buffer<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>            written <span style=color:#f92672>=</span> buffer<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Buffer as much as possible. */</span>
</span></span><span style=display:flex><span>        memcpy(self<span style=color:#f92672>-&gt;</span>buffer <span style=color:#f92672>+</span> self<span style=color:#f92672>-&gt;</span>write_end, buffer<span style=color:#f92672>-&gt;</span>buf, avail);
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>write_end <span style=color:#f92672>+=</span> avail;
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>pos <span style=color:#f92672>+=</span> avail;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* XXX Modifying the existing exception e using the pointer w
</span></span></span><span style=display:flex><span><span style=color:#75715e>           will change e.characters_written but not e.args[2].
</span></span></span><span style=display:flex><span><span style=color:#75715e>           Therefore we just replace with a new error. */</span>
</span></span><span style=display:flex><span>        _set_BlockingIOError(<span style=color:#e6db74>&#34;write could not complete without blocking&#34;</span>,
</span></span><span style=display:flex><span>                             avail);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Py_CLEAR(res);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Adjust the raw stream position if it is away from the logical stream
</span></span></span><span style=display:flex><span><span style=color:#75715e>       position. This happens if the read buffer has been filled but not
</span></span></span><span style=display:flex><span><span style=color:#75715e>       modified (and therefore _bufferedwriter_flush_unlocked() didn&#39;t rewind
</span></span></span><span style=display:flex><span><span style=color:#75715e>       the raw stream by itself).
</span></span></span><span style=display:flex><span><span style=color:#75715e>       Fixes issue #6629.
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    offset <span style=color:#f92672>=</span> RAW_OFFSET(self);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_buffered_raw_seek(self, <span style=color:#f92672>-</span>offset, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>        self<span style=color:#f92672>-&gt;</span>raw_pos <span style=color:#f92672>-=</span> offset;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Then write buf itself. At this point the buffer has been emptied. */</span>
</span></span><span style=display:flex><span>    remaining <span style=color:#f92672>=</span> buffer<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>    written <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (remaining <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>-&gt;</span>buffer_size) {
</span></span><span style=display:flex><span>        Py_ssize_t n <span style=color:#f92672>=</span> _bufferedwriter_raw_write(
</span></span><span style=display:flex><span>            self, (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) buffer<span style=color:#f92672>-&gt;</span>buf <span style=color:#f92672>+</span> written, buffer<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>-</span> written);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* Write failed because raw file is non-blocking */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (remaining <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>-&gt;</span>buffer_size) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Can&#39;t buffer everything, still buffer as much as possible */</span>
</span></span><span style=display:flex><span>                memcpy(self<span style=color:#f92672>-&gt;</span>buffer,
</span></span><span style=display:flex><span>                       (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) buffer<span style=color:#f92672>-&gt;</span>buf <span style=color:#f92672>+</span> written, self<span style=color:#f92672>-&gt;</span>buffer_size);
</span></span><span style=display:flex><span>                self<span style=color:#f92672>-&gt;</span>raw_pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                ADJUST_POSITION(self, self<span style=color:#f92672>-&gt;</span>buffer_size);
</span></span><span style=display:flex><span>                self<span style=color:#f92672>-&gt;</span>write_end <span style=color:#f92672>=</span> self<span style=color:#f92672>-&gt;</span>buffer_size;
</span></span><span style=display:flex><span>                written <span style=color:#f92672>+=</span> self<span style=color:#f92672>-&gt;</span>buffer_size;
</span></span><span style=display:flex><span>                _set_BlockingIOError(<span style=color:#e6db74>&#34;write could not complete without &#34;</span>
</span></span><span style=display:flex><span>                                     <span style=color:#e6db74>&#34;blocking&#34;</span>, written);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            PyErr_Clear();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        written <span style=color:#f92672>+=</span> n;
</span></span><span style=display:flex><span>        remaining <span style=color:#f92672>-=</span> n;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Partial writes can return successfully when interrupted by a
</span></span></span><span style=display:flex><span><span style=color:#75715e>           signal (see write(2)).  We must run signal handlers before
</span></span></span><span style=display:flex><span><span style=color:#75715e>           blocking another time, possibly indefinitely. */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (PyErr_CheckSignals() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (self<span style=color:#f92672>-&gt;</span>readable)
</span></span><span style=display:flex><span>        _bufferedreader_reset_buf(self);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (remaining <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        memcpy(self<span style=color:#f92672>-&gt;</span>buffer, (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) buffer<span style=color:#f92672>-&gt;</span>buf <span style=color:#f92672>+</span> written, remaining);
</span></span><span style=display:flex><span>        written <span style=color:#f92672>+=</span> remaining;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    self<span style=color:#f92672>-&gt;</span>write_pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* TODO: sanity check (remaining &gt;= 0) */</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>-&gt;</span>write_end <span style=color:#f92672>=</span> remaining;
</span></span><span style=display:flex><span>    ADJUST_POSITION(self, remaining);
</span></span><span style=display:flex><span>    self<span style=color:#f92672>-&gt;</span>raw_pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>end:
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> PyLong_FromSsize_t(written);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error:
</span></span><span style=display:flex><span>    LEAVE_BUFFERED(self)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在写入 Buffer 的 <code>while</code> 循环中发现如下注释和代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* Partial writes can return successfully when interrupted by a
</span></span></span><span style=display:flex><span><span style=color:#75715e>   signal (see write(2)).  We must run signal handlers before
</span></span></span><span style=display:flex><span><span style=color:#75715e>   blocking another time, possibly indefinitely. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (PyErr_CheckSignals() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> error;
</span></span></code></pre></div><p>显然，这里就是 Python 唤起信号处理器的地方。<code>PyErr_CheckSignals()</code> 的作用就是检查信号标志位，如果设置了标志位就立即调用信号处理器。在 Python 源代码中的搜索「<a href="https://github.com/python/cpython/search?l=C&q=PyErr_CheckSignals">PyErr_CheckSignals</a>」，能找到20多处调用。果然，官方文档中的描述是有问题的——事实上，Python 不仅仅在两次 bytecode 执行之间会调用信号处理器，在内置函数中也可能会调用信号处理器。</p><script src=/js/post.js></script></div><div class=taxonomy data-pagefind-ignore><div class=taxonomy-tags><ul class=tags><li>#<a data-pagefind-filter=标签 href=https://www.fournoas.com/tags/Python/>Python</a></li></ul></div></div><div class=pagination data-pagefind-ignore><a href=/moments/202210/1667136126/ class="left arrow">上一篇</a>
<a href=/posts/handling-signal-in-python-on-different-platforms/ class="right arrow">下一篇：<br>Python 信号处理在不同平台上的差异</a>
<a href=# class=top>返回顶部</a></div></main><footer><span>&copy; <time datetime="2022-11-04 03:32:00.271225727 +0000 UTC m=+0.332436881">2022</time> fournoas.com. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://pagefind.app>Pagefind</a>, theme by <a href=https://github.com/EmielH/tale-hugo>Tale</a>.</span></footer><script src=/js/main.js></script></body></html>