<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="如果还不清楚什么是 CQRS 和 Event Sourcing 模式，可以先阅读下面的两篇文章：

命令和查询责任分离模式
事件溯源模式

Event Sourcing 模式，即事件溯源模式。该模式使用只可追加的存储来记录对数据所进行的所有操作，而不是存储领域数据的当前状态。其中，存储 Event 记录的介质称作 Event Store。
CQRS（Command Query Responsibility Segregation），即命令和查询责任分离。该模式使用单独的接口来隔离更新数据（命令）的操和读取数据（查询）的操作。这意味着用于查询和更新的数据模型是不同的。"><title>CQRS/Event Sourcing 模式实践 &#183; 白汤四物</title>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/rainbow.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href rel=alternate type=application/rss+xml title=白汤四物><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-3GNL63B62Q"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3GNL63B62Q")</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/search/><span>搜索</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main data-pagefind-body><div class="page post"><h1 class=post-title data-pagefind-meta=title>CQRS/Event Sourcing 模式实践</h1><div class=post-line></div><div class=post-info><span>作者</span>
<span data-pagefind-meta=作者>Fournoas
</span><span>写于&nbsp;</span><time datetime="2019-10-30 00:00:00 +0000 UTC" data-pagefind-meta=日期>2019年10月30日</time>
<span>发布在&nbsp;</span><ul class=categories><li><a data-pagefind-filter=分类 href=/categories/coding/>Coding</a></li></ul></div><p>如果还不清楚什么是 CQRS 和 Event Sourcing 模式，可以先阅读下面的两篇文章：</p><ul><li><a href=https://iambowen.gitbooks.io/cloud-design-pattern/content/patterns/cqrs.html target=_blank rel=noopener>命令和查询责任分离模式</a></li><li><a href=https://iambowen.gitbooks.io/cloud-design-pattern/content/patterns/event-sourcing.html target=_blank rel=noopener>事件溯源模式</a></li></ul><p>Event Sourcing 模式，即<strong>事件溯源模式</strong>。该模式使用只可追加的存储来记录对数据所进行的所有操作，而不是存储领域数据的当前状态。其中，存储 Event 记录的介质称作 <strong>Event Store</strong>。</p><p>CQRS（Command Query Responsibility Segregation），即<strong>命令和查询责任分离</strong>。该模式使用单独的接口来隔离更新数据（命令）的操和读取数据（查询）的操作。这意味着用于查询和更新的数据模型是不同的。</p><p>在实践中，通常将 Event Sourcing 模式与 CQRS 模式相配合。通过命令接口将事件持久化存储，通过查询接口读取 <strong>Materialized View</strong>（物化视图）。物化视图可以由事件处理器实时或定期生成。</p><figure><img src=/posts/CQRS-and-event-sourcing-pattern-in-practice/ill-1.png alt=img></figure><h2 id=命令和事件>命令和事件</h2><h2 id=基于消息的系统>基于消息的系统</h2><p>从上图可以看出，整个系统是基于消息驱动的。事件就是消息，命令接口可以视为消息的生产者，事件处理器就是消息的消费者。Event Store 是持久化存储介质，能保证数据不会丢失。命令接口只要确保事件进入 Event Store 就能返回，而事件处理器在后台运行，为查询接口生成物化视图。整个系统没有阻塞操作，十分高效。</p><p>缺点是，查询接口获得的数据并非实时的，系统只能保证数据的最终一致性。不过这点对于普通应用来说都不是问题，毕竟在网页或 APP 中显示的信息，本质上都属于“历史数据”。</p><h2 id=并发并行和数据最终一致性>并发、并行和数据最终一致性</h2><p>假设一个理想化的 Event Sourcing & CQRS 系统，所有的事件都严格按顺序存储，那么只要按顺序遍历事件，就可以得到系统的任意时间的状态。事件就好比数据库通过日志，并且每个事件都是原子操作。每处理一个事件，就能得到唯一对应的系统状态。这样就可以保证数据的一致性。</p><p>不过在这样的系统里，事件无法被并行处理，命令接口会成为性能瓶颈。为了实现事件的并行处理，就需要部署多个事件处理器，而每个处理器仅负责处理一个类型的事件，并且要保证不同类型的事件的处理顺序不会影响到数据的一致性。</p><p>一种可行的事件分类方式是按照<strong>聚合根</strong>分类。每个逻辑处理器仅处理仅负责处理一个聚合根的事件，每个事件也仅涉及到一个聚合根。如果一个操作需要涉及到多个聚合根，那就等于是一个分布式事务。分布式事务的提交方案有 <strong>2PC</strong>/<strong>3PC</strong> 等。根据事件溯源模式的特性，我们采用 <strong>Saga</strong> 分布式事务解决方案来实现数据的最终一致性。</p><div class=note><div class=note-content><p>关于 Saga 模式，可以参考《<a href=https://www.jianshu.com/p/e4b662407c66 target=_blank rel=noopener>分布式事务：Saga模式</a>》和《<a href=https://servicecomb.apache.org/cn/docs/distributed-transactions-saga-implementation/ target=_blank rel=noopener>Saga分布式事务解决方案与实践</a>》。</p></div></div><h2 id=命令接口允许返回数据>命令接口允许返回数据</h2><p>标准 CQRS 模式的命令接口，只接受写入参数，不返回数据。要获取数据，必须通过查询接口。然而在实践中要遵守着一条会带来很多麻烦。首先，我们无法得知命令是否执行成功；其次，对基于数据库自增字段的实体 ID，我们无法得知新建实体的 ID。</p><p>因此，命令接口返回数据是有必要的。具体实现上，可以分为两种模式：</p><ol><li>异步模式：返回一个唯一标识，通过该唯一标识，异步查询执行结果；</li><li>同步模式：阻塞直到命令被处理完毕，并将结果返回。</li></ol><h2 id=event-store-存储介质>Event Store 存储介质</h2><p>当系统运行一段时间后，Event Store 保存的事件会积累得越来越多。数据存储和生成物化视图都会成为瓶颈。一种可行的解决方案是定期生成系统快照，对于快照生成之前的事件数据可以离线归档，线上只要保留上次快照后新生成的事件数据即可。</p><p>Event Store 的存储介质要支持顺序写入，能够使用索引快速检索。</p><h2 id=物化视图>物化视图</h2><p>物化视图不是领域模型的视图，也不是系统模型的视图，而是面向查询的视图。</p><h2 id=案例>案例</h2><p>以用户之间转账为例，假设我们从账户 A 转一笔金额为 x 的资金到账户 B。我们将整个事务拆分为两个子事务：</p><ol><li>T<sub>1</sub> = 从账户 A 中扣除数量为 x 的资金；</li><li>T<sub>2</sub> = 向账户 B 中添加数量为 x 的资金。</li></ol><p>如果两步都执行成功，则转账事务完成；如果 T<sub>1</sub> 执行失败，比如余额不足，则转账失败；如果 T<sub>2</sub> 执行失败，比如账户 B 不存在，则回滚 T<sub>1</sub>，转账失败。</p><p>当然，这只是个简化的模型，需要优化。现实情况可能会更加复杂。比如规定账号被锁定，余额不能变化。那么有可能会发生当 T<sub>2</sub> 执行失败，而账户 A 又已经被锁定，导致 T<sub>1</sub> 无法回滚的情况。我们必须采取某些补偿机制来保证所有子事务都是可回滚的。</p><p>从领域模型的角度思考，转账行为应该是一个聚合根，它有唯一的标识 ID（流水号）。甚至对于复杂的系统，转账系统可以单独视作一个子域。</p><ol><li>创建转账事务，初始状态为 PENDING；</li><li>账户 A 扣款；</li><li>如果扣款成功</li></ol></div><div class=taxonomy data-pagefind-ignore><div class=taxonomy-tags><ul class=tags><li>#<a data-pagefind-filter=标签 href=/tags/CQRS/>CQRS</a></li><li>#<a data-pagefind-filter=标签 href=/tags/Event-Sourcing/>Event Sourcing</a></li></ul></div></div><div class=pagination data-pagefind-ignore><a href=/posts/dutch-baby-pancake/ class="left arrow">上一篇：<br>荷兰宝贝松饼</a>
<a href=/moments/201910/1571883120/ class="right arrow">下一篇</a>
<a href=# class=top>返回顶部</a></div></main><script src=/js/page.js></script><script src=/js/main.js></script><footer><span>&copy; <time datetime="2025-04-24 10:20:05.329458174 +0000 UTC m=+0.742496290">2025</time> fournoas.com. Powered by <a href=https://gohugo.io/>Hugo</a> 0.146.7.</span></footer></body></html>