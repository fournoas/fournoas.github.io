<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="通过 Windows API GetSystemMenu 获取窗口系统菜单（即窗口标题栏右键菜单）句柄，可以实现自定义窗口菜单的功能。但若获取的窗口菜单句柄来自其他进程的窗口，便会引发问题。"><title>GetSystemMenu() 可能损坏其他进程的窗口菜单 &#183; 白汤四物</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/rainbow.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href rel=alternate type=application/rss+xml title=白汤四物><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-3GNL63B62Q"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3GNL63B62Q")</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/search/><span>搜索</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main data-pagefind-body><div class="page post"><h1 class=post-title data-pagefind-meta=title>GetSystemMenu() 可能损坏其他进程的窗口菜单</h1><div class=post-line></div><div class=post-info><span>作者</span>
<span data-pagefind-meta=作者>Fournoas
</span><span>写于&nbsp;</span><time datetime="2025-06-03 00:00:00 +0000 UTC" data-pagefind-meta=日期>2025年6月3日</time>
<span>发布在&nbsp;</span><ul class=categories><li><a data-pagefind-filter=分类 href=/categories/coding/>Coding</a></li></ul></div><p>通过 Windows API <a href=https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getsystemmenu target=_blank rel=noopener>GetSystemMenu</a> 获取窗口系统菜单（即窗口标题栏右键菜单）句柄，可以实现自定义窗口菜单的功能。但若获取的窗口菜单句柄来自其他进程的窗口，便会引发问题。</p><p>下面的代码展示了自定义 Windows 画图程序的窗口菜单：</p><pre><span class=code-lang>c&#43;&#43;</span><code class=language-c++>#include &lt;iostream&gt;
#include &lt;windows.h&gt;

int main()
{
    std::cout &lt;&lt; &#34;按任意键自定义画图窗口菜单...&#34; &lt;&lt; std::endl;
    std::cin.get();
    auto hWnd = FindWindowW(L&#34;MSPaintApp&#34;, NULL);
    if (hWnd == NULL) {
        std::cerr &lt;&lt; &#34;未找到画图窗口！请先打开画图程序。&#34; &lt;&lt; std::endl;
        return 1;
    }
    auto hMenu = GetSystemMenu(hWnd, FALSE);
    if (hMenu == NULL) {
        std::cerr &lt;&lt; &#34;获取窗口菜单失败！&#34; &lt;&lt; std::endl;
        return 1;
    }
    std::cout &lt;&lt; &#34;菜单句柄值: &#34; &lt;&lt; hMenu &lt;&lt; std::endl;
    if (!IsMenu(hMenu)) {
        std::cerr &lt;&lt; &#34;菜单句柄无效&#34; &lt;&lt; std::endl;
        return 1;
    }
    AppendMenuW(hMenu, MF_STRING, 0x1001, L&#34;自定义菜单项&#34;);
    std::cout &lt;&lt; &#34;按任意键移除菜单项...&#34; &lt;&lt; std::endl;
    std::cin.get();
    RemoveMenu(hMenu, 0x1001, MF_BYCOMMAND);
    std::cout &lt;&lt; &#34;按任意键退出程序...&#34; &lt;&lt; std::endl;
    std::cin.get();
}</code></pre><p>首先运行 Windows 自带的画图程序，然后编译并运行上面的示例程序。第一次运行时，该程序工作正常。待该程序退出再次运行它，便会得到错误提示：<samp>菜单句柄无效</samp>。另外，通过观察画图程序的窗口菜单，也可以发现在示例程序退出后，菜单样式发生了改变。</p><figure><img src=/posts/GetSystemMenu-will-corrupt-window-menu-of-external-process/system-menu-1.png alt=图1：示例程序运行前的画图窗口菜单><figcaption><p>图1：示例程序运行前的画图窗口菜单</p></figcaption></figure><figure><img src=/posts/GetSystemMenu-will-corrupt-window-menu-of-external-process/system-menu-2.png alt=图2：示例程序退出后的画图窗口菜单><figcaption><p>图2：示例程序退出后的画图窗口菜单</p></figcaption></figure><p>微软官方文档中对此现象并没有特别说明。不过我猜测原因如下：虽然文档中明确说 <code>GetSystemMenu()</code> 获取的是窗口菜单的副本，但是实际上该窗口菜单的所有权转移到了调用此 API 的进程，也就是示例程序进程。当示例程序退出后，该菜单对象便被销毁了。第二次运行示例程序，<code>GetSystemMenu()</code> 获取到的仍是之前的窗口句柄（两次运行输出的菜单句柄值一致），因此 <code>IsMenu()</code> 检测判断该句柄无效。图 1 中的窗口菜单其实是窗口管理器创建的应用了主题样式的菜单，而图 2 才是真正的窗口默认菜单，只是 <code>GetSystemMenu()</code> 无法获取到它的句柄。</p><p>解决方案有两种：</p><ol><li>在示例程序退出前调用 <code>GetSystemMenu(hWnd, TRUE)</code> 重置窗口菜单。不过某些程序会对窗口菜单进行自定义，比如 Edge 浏览器，该方法会让自定义菜单项失效。</li><li>使用 <code>SetWindowsHookEx()</code> 创建钩子，将 DLL 注入到目标进程中，在目标进程中调用 <code>GetSystemMenu()</code> ，避免发生菜单所有权转移。</li></ol><hr><div class=note><div class=note-content><p>在本篇发布后不久，我发现了一篇 <a href="https://devblogs.microsoft.com/oldnewthing/20100528-00/?p=13893" target=_blank rel=noopener>Blog</a> 文章，其作者是微软官方的开发人员 <a href=https://devblogs.microsoft.com/oldnewthing/author/oldnewthing target=_blank rel=noopener>Raymond Chen</a>。该文章部分证实了我之前的猜测，因此不再对原文做修改，而是将新内容补充在文末。</p></div></div><blockquote><p><strong>Every window with the WS_SYSMENU style has a system menu, but it&rsquo;s not there until it needs to be</strong></p><p>I mentioned last time that <a href="https://devblogs.microsoft.com/oldnewthing/20100527-00/?p=13903" target=_blank rel=noopener>there’s an optimization in the treatment of the system menu</a> which significantly reduces the number of menus in the system. When a window has the <code>WS_SYSMENU</code> window style, it has a system menu, but until somebody calls <code>Get­System­Menu</code> on that window, nobody knows what its menu handle is. Until that point, the window manager doesn’t actually have to commit to creating a menu for the window; it can just pretend that the window has one. (This technique goes by the fancy name <em>lazy initialization</em>.) The window manager creates a global default system menu which contains the standard system menu items. If somebody presses Alt+Space or otherwise calls up the system menu for a window that has never had <code>Get­System­Menu</code> called on it, the window manager just uses the global default system menu, since it knows that nobody has customized the menu. (You can’t customize a menu you don’t have the handle to!) Since most people never customize their system menu, this optimization avoids cluttering the desktop heap with identical copies of the same menu. This was a particularly important optimization back in the 16-bit days, when all window manager objects had to fit into a single 64KB heap (known as <em>System Resources</em>). If you are really sneaky, you can catch a glimpse of the elusive <em>global default system menu</em> as it whizzes by: As with any other popup menu, the handle to the menu being displayed is passed to your window’s <code>WM_INIT­MENU­POPUP</code>, and if your program has never called <code>Get­System­Menu</code>, the handle that you will see is the global default system menu. Mind you, you can’t do much to this menu, since the window manager blocks any attempt to modify it. (Otherwise, your program’s menu modification would have an unintended effect on the menus of other programs!)</p><p>Therefore, if your program is in the habit of modifying its system menu in its <code>WM_INIT­MENU­POPUP</code> handler, you should stick a dummy call to <code>Get­System­Menu</code> in your <code>WM_CREATE</code> handler to force your system menu to change from a pretend system menu to a real one.</p></blockquote><p>Windows 窗口管理器不会立即为每个具有 <code>WS_SYSMENU</code> 风格的窗口创建窗口菜单，而是共用一个全局的默认窗口菜单，也就是上文中图 2 显示的那个菜单，由于某种原因，uxtheme 视觉样式没有被应用在该菜单上，所以看上去样式不一致。直到对该窗口调用 <code>Get­System­Menu()</code> ，这表示该窗口可能需要有一个自定义窗口菜单，此时窗口管理器才会为该窗口创建一个独立的窗口菜单。</p><p>新建窗口菜单的所有权属于第一次对该窗口调用 <code>Get­System­Menu()</code> 的进程。这也解释了，为什么 Edge 浏览器（或其他拥有自定义系统菜单的窗口）的系统菜单不受示例程序的影响——因为这些窗口的所属进程已经调用过 <code>Get­System­Menu()</code> 了。</p><p>根据上述原理，我们可以用通过判断窗口菜单是否为全局默认窗口菜单来决定是否重置窗口菜单——如果是默认窗口菜单，则重置；如果是自定义窗口菜单，则无需处理。具体实现代码如下：</p><pre><span class=code-lang>c&#43;&#43;</span><code class=language-c++>bool IsDefaultSystemMenu(HMENU hMenu)
{
    UINT defaultIDs[] = { 
        SC_RESTORE, 
        SC_MOVE, 
        SC_SIZE, 
        SC_MINIMIZE, 
        SC_MAXIMIZE, 
        0, 
        SC_CLOSE 
    };
    auto itemCount = GetMenuItemCount(hMenu);
    if (itemCount != sizeof(defaultIDs)) return false;
    for (auto i = 0; i &lt; itemCount; i&#43;&#43;) {
        auto itemID = GetMenuItemID(hMenu, i);
        if (itemID != defaultIDs[i]) return false;
    }
    return true;
}

/**
 * 进程退出前调用下面的代码
 * 如果是默认窗口菜单则重置
 */
if (IsDefaultSystemMenu(hMenu)) {
    GetSystemMenu(hWnd, TRUE);
}</code></pre></div><div class=taxonomy data-pagefind-ignore></div><div class=pagination data-pagefind-ignore><a href=/moments/202506/1749620172/ class="left arrow">上一篇</a>
<a href=/posts/summary-of-Retrial-of-Song-Jiaoren-Case/ class="right arrow">下一篇：<br>《宋案重审》概要</a>
<a href=# class=top>返回顶部</a></div></main><script src=/js/page.js></script><script src=/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/highlight.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/scala.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/nim.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/powershell.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/nginx.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/delphi.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/dos.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/haxe.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://unpkg.com/highlightjs-svelte/dist/svelte.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://unpkg.com/highlightjs-zig/dist/zig.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://unpkg.com/highlightjs-redbol/dist/redbol.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=/js/code.js></script><script>hljs.highlightAll(),hljs.initLineNumbersOnLoad(),hljs.initSelectLines()</script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js crossorigin=anonymous referrerpolicy=no-referrer onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"\\[",right:"\\]",display:!0},{left:"$$",right:"$$",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><footer><span>&copy; <time datetime="2025-10-21 02:07:07.880443506 +0000 UTC m=+0.810252140">2025</time> fournoas.com. Powered by <a href=https://gohugo.io/>Hugo</a> v0.151.2.</span></footer></body></html>