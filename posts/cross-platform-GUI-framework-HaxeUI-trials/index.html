<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="HaxeUI 是一款跨平台 GUI 框架，支持网页、桌面和移动端。 框架前端使用 Hexo 语言开发。框架后端使用图形引擎或者原生跨平台 GUI 框架，比如 OpenFL, NME, Kha,PixiJS, wxWidgets, Winforms 等。最终生成 C++ 代码编译成本地可执行文件或者 HTML 代码。在各种后端中，除了 wxWidgets 和 Winforms 使用原生组件外，其他都是使用图形引擎绘制或者生成 HTML 代码。

  Haxe 也是一个比较有意思的语言。它本身不能进行本地编译，而是转译成其他语言，比如 Lua, PHP, Java, Python, C++, C# 等，也可以编译成 Neko 或 HashLink 虚拟机的字节码（详见 Haxe Compiler Targets）。Haxe 语言诞生于 2005 年，算是历史久远了，然而其社区却一直不温不火，网上也很难找到中文资料。 Haxelib 上的开发者提交的三方库数量和 Python 的 PyPi 相比，只能说是聊胜于无。"><title>试用跨平台 GUI 框架 HaxeUI &#183; 白汤四物</title>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/rainbow.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href rel=alternate type=application/rss+xml title=白汤四物><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-3GNL63B62Q"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3GNL63B62Q")</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/search/><span>搜索</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main data-pagefind-body><div class="page post"><h1 class=post-title data-pagefind-meta=title>试用跨平台 GUI 框架 HaxeUI</h1><div class=post-line></div><div class=post-info><span>作者</span>
<span data-pagefind-meta=作者>Fournoas
</span><span>写于&nbsp;</span><time datetime="2024-02-19 00:00:00 +0000 UTC" data-pagefind-meta=日期>2024年2月19日</time>
<span>发布在&nbsp;</span><ul class=categories><li><a data-pagefind-filter=分类 href=/categories/coding/>Coding</a></li></ul></div><p><a href=https://www.haxeui.org/ target=_blank rel=noopener>HaxeUI</a> 是一款跨平台 GUI 框架，支持网页、桌面和移动端。 框架前端使用 Hexo 语言开发。框架后端使用图形引擎或者原生跨平台 GUI 框架，比如 OpenFL, NME, Kha,PixiJS, wxWidgets, Winforms 等。最终生成 C++ 代码编译成本地可执行文件或者 HTML 代码。在各种后端中，除了 wxWidgets 和 Winforms 使用原生组件外，其他都是使用图形引擎绘制或者生成 HTML 代码。</p><figure><img src=/posts/cross-platform-GUI-framework-HaxeUI-trials/haxeui.jpg alt=img></figure><p><a href=https://haxe.org/ target=_blank rel=noopener>Haxe</a> 也是一个比较有意思的语言。它本身不能进行本地编译，而是转译成其他语言，比如 Lua, PHP, Java, Python, C++, C# 等，也可以编译成 Neko 或 HashLink 虚拟机的字节码（详见 <a href=https://haxe.org/documentation/introduction/compiler-targets.html target=_blank rel=noopener>Haxe Compiler Targets</a>）。Haxe 语言诞生于 2005 年，算是历史久远了，然而其社区却一直不温不火，网上也很难找到中文资料。 <a href=https://lib.haxe.org/ target=_blank rel=noopener>Haxelib</a> 上的开发者提交的三方库数量和 Python 的 PyPi 相比，只能说是聊胜于无。</p><p>看来也不能对 HaxeUI 抱有太大的希望，让我先在 Windows 上尝试看看。</p><h2 id=安装开发环境>安装开发环境</h2><p>首先安装 Haxe 和 HaxeUI（此处使用 Scoop 进行安装）：</p><pre><span class=code-lang>shell</span><code class=language-shell>scoop install haxe
haxelib install haxeui-core</code></pre><p>通过 <code>haxelib run haxeui-core install</code> 命令可以查看 HaxeUI 支持的后端：</p><pre><code class=language-text> ERROR: no backend specified

 Please use one of the following:

     html5 | hxwidgets | openfl | nme | pixijs | kha | winforms | android | flixel | electron | qt | heaps | raylib | pdcurses | tauri</code></pre><p>然而奇怪的是，命令返回的可选后端和官网文档不一致，而且 android, flixel, electron, qt, heaps, raylib, pdcurses, tauri 这几个后端都不可用。不知道是操作系统的平台限制还是这玩意儿根本就是半成品。</p><p>本文仅测试跨平台桌面版，选用 haxeui-hxwidgets, haxeui-openfl, haxeui-nme 和 haxeui-kha 四个后端。</p><h2 id=haxeui-hxwidgets>haxeui-hxwidgets</h2><p>haxeui-hxwidgets 是 HaxeUI 的 <a href=https://www.wxwidgets.org/ target=_blank rel=noopener>wxWidgets</a> 后端。 它生成一个通过 wxWidgets 框架从本机组件构建的 GUI 。</p><p>可以通过 haxeui-core 自动安装 hxWidgets 后端所依赖的库：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core install hxwidgets</code></pre><p>也可以手动安装：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib install hxcpp
haxelib install hxwidgets
haxelib install haxeui-hxwidgets</code></pre><p>此外还需要下载并编译 wxWidgets 的 C++ 库。我尝试了使用 <code>vcpkg install wxwidgets</code> 来安装编译，但是 HaxeUI 似乎无法识别，只能通过手动安装。</p><ol><li>从 <a href=https://www.wxwidgets.org/downloads/ target=_blank rel=noopener>https://www.wxwidgets.org/downloads/</a> 下载 wxWidgets 最新版本，目前最新版本是 3.2.4 ；</li><li>解压后保存在任意路径下，此处路径为 <em>C:\wxWidgets-3.2.4</em> ；</li><li>开始菜单中的 Visual Studio 项目下，选择 <em>x86 Native Tools Command Prompt for VS 2022</em> ，打开编译环境命令行窗口；</li><li>执行命令编译：<pre><span class=code-lang>shell</span><code class=language-shell>cd /d C:\wxWidgets-3.2.4\build\msw\
nmake -f makefile.vc BUILD=release
nmake -f makefile.vc BUILD=release SHARED=1</code></pre></li></ol><p>如果编译成功，则会在 <em>C:\wxWidgets-3.2.4\lib</em> 目录下生成 vc_lib 和 vc_dll 两个目录。</p><p>使用下面的命令在当前目录下创建一个 haxeui-hxwidgets 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core create hxwidgets</code></pre><p>在编译项目之前需要先设置一个名为 <code>WXWIN</code> 的环境变量指示 wxWidgets 的安装路径：</p><pre><span class=code-lang>shell</span><code class=language-shell>set WXWIN=C:\wxWidgets-3.2.4</code></pre><p>在 PowerShell 命令行下则使用：</p><pre><span class=code-lang>powershell</span><code class=language-powershell>$ENV:WXWIN=&#34;C:\wxWidgets-3.2.4&#34;</code></pre><p>使用如下命令编译 haxeui-hxwidgets 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core build hxwidgets</code></pre><p>默认配置下，编译会链接 wxWidgets 静态库。可以编辑项目根目录下的 <em>hxwidgets.hxml</em> 配置文件，将 <code>-D WXSTATIC</code> 修改为 <code>-D WXDLL</code> 来启用动态库链接。</p><p>需要注意的是，<strong>默认编译出来的程序无法正确显示中文字符</strong>。其原因是 hxWidgets 会将用户界面上的字符串都转换成 UTF-8 编码，而 Windows 不同于 Linux 系统，中文环境默认使用 GBK (CP936) 编码。要解决这个问题，还需要通过 Manifest 来指定程序的编码。</p><p>首先，创建一个 Manifest.xml 文件，内容如下：</p><pre><span class=code-lang>xml</span><code class=language-xml>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; standalone=&#34;yes&#34;?&gt;
&lt;assembly manifestVersion=&#34;1.0&#34; xmlns=&#34;urn:schemas-microsoft-com:asm.v1&#34;&gt;
  &lt;assemblyIdentity type=&#34;win32&#34; name=&#34;MyHaxeUIApp&#34; version=&#34;6.0.0.0&#34;/&gt;
  &lt;application&gt;
    &lt;windowsSettings&gt;
      &lt;activeCodePage xmlns=&#34;http://schemas.microsoft.com/SMI/2019/WindowsSettings&#34;&gt;UTF-8&lt;/activeCodePage&gt;
    &lt;/windowsSettings&gt;
  &lt;/application&gt;
&lt;/assembly&gt;</code></pre><p>然后执行：</p><pre><span class=code-lang>shell</span><code class=language-shell>mt -manifest Manifest.xml -outputresource:Main.exe;#1</code></pre><div class=note><div class=note-content><p>mt.exe 并不在默认的 PATH 路径下，而是由 Windows Kits 提供。要在命令行中执行该命令，可以在之前的 <em>x86 Native Tools Command Prompt for VS 2022</em> 命令行窗口中执行。</p></div></div><p>由于 hxWidgets 使用了原生控件，因此其控件样式无法随意更改，比如不支持 <code>font-style</code> 设置控件的字体样式等。</p><h2 id=haxeui-openfl>haxeui-openfl</h2><p>haxeui-openfl 是 HaxeUI 的 <a href=https://www.openfl.org/ target=_blank rel=noopener>OpenFL</a> 后端。</p><p>可以通过 haxeui-core 自动安装 OpenFL 后端所依赖的库：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core install openfl
haxelib run openfl setup</code></pre><p>也可以手动安装：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib install haxeui-openfl
haxelib install openfl
haxelib run openfl setup</code></pre><p>使用下面的命令在当前目录下创建一个 haxeui-openfl 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core create openfl</code></pre><p>使用如下命令编译 haxeui-openfl 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core build openfl windows</code></pre><p>同样需要注意的是，<strong>默认编译出来的程序也无法显示中文字符</strong>。和 hxWidgets 不同的是， OpenFL 不是由于编码问题，而是由于 OpenFL 无法使用系统的中文字体导致的。我们可以打包一个中文字体来显示中文。</p><div class=note><div class=note-content><p>OpenFL 支持 OTF 和 TTF 格式的字体文件，不支持 TTC 格式的文件文件。TTC 是一系列字体的打包集合文件，可以转换成 TTF 格式。</p></div></div><p>下载思源宋体，将 source-han-serif.otf 字体文件存放在项目 <em>assets/fonts</em> 路径下。编辑项目根目录下 <em>application.xml</em> 文件，在 <code>&lt;project>...&lt;/project></code> 中添加一行：</p><pre><span class=code-lang>xml</span><code class=language-xml>&lt;assets path=&#34;assets/fonts&#34; rename=&#34;fonts&#34; /&gt;</code></pre><p>在 <em>main-view.xml</em> 中使用中文字体：</p><pre><span class=code-lang>xml</span><code class=language-xml>&lt;style&gt;
    .button {
        font-size: 12px;
        font-name: &#34;fonts/source-han-serif.otf&#34;;
    }
&lt;/style&gt;</code></pre><p>另一个比较严重的问题是，<strong>OpenFL 后端的文本框在开启输入法时无法显示输入法候选窗口</strong>。虽然能够输入中文，但这相当于在盲打了。这个缺陷导致该后端几乎无法在生产环境中使用。</p><p>OpenFL 的本地编译的后端是 <a href=https://github.com/openfl/lime target=_blank rel=noopener>lime</a> ，而 lime 的后端又是 <a href=https://libsdl.org/ target=_blank rel=noopener>SDL</a> ……这层层套娃的关系导致想要定位问题都比较困难。</p><p>除此之外，偶尔发生菜单排版错乱，同时按钮失效的问题（遇到过几次，暂时还不清楚触发的条件）；还有偶尔会触发 TextField 崩溃弹框提示 Invalid object 的问题。</p><figure><img src=/posts/cross-platform-GUI-framework-HaxeUI-trials/invalid-object.png alt=invalid-object></figure><h2 id=haxeui-nme>haxeui-nme</h2><p>haxeui-nme 是 HaxeUI 的 <a href=https://github.com/haxenme/nme target=_blank rel=noopener>NME</a> 后端。</p><p>可以通过 haxeui-core 自动安装 NME 后端所依赖的库：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core install nme
haxelib run nme setup</code></pre><p>也可以手动安装：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib install haxeui-nme
haxelib install nme
haxelib run nme setup</code></pre><p>使用下面的命令在当前目录下创建一个 haxeui-nme 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core create nme</code></pre><p>使用如下命令编译 haxeui-nme 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core build nme windows</code></pre><p>与 hxWidgets 和 OpenFL 这两个后端相比，这个后端还算省心，默认编译就能显示中文，只是默认字体有点丑。也可以像 haxeui-openfl 一样，通过编辑 <em>project.nmml</em> 项目配置文件来添加自定义字体。</p><p>此外，和 OpenFL 一样，<strong>NME 后端的文本框在开启输入法时也无法显示输入法候选窗口</strong>，而且一次只能输入一个中文字符，无法输入词语短句。另外还存在输入光标丢失、选中文本后文本不可见等诸多问题。</p><h2 id=haxeui-kha>haxeui-kha</h2><p>haxeui-kha 是 HaxeUI 的 <a href=https://github.com/Kode/Kha target=_blank rel=noopener>Kha</a> 后端。安装此后端需要从 GitHub 上下载几百兆的编译环境。最后编译失败，原因不明，也懒得折腾。放弃。</p><h2 id=haxeui-flixel>haxeui-flixel</h2><p>haxeui-flixel 是 HaxeUI 的 <a href=https://github.com/AdamAtomic/flixel target=_blank rel=noopener>flixel</a> 后端。</p><p>奇怪的是，haxeui-flixel 无法通过 <code>haxelib run haxeui-core install flixel</code> 命令进行安装，提示 <code>Install not found for "flixel"</code> 错误。</p><p>手动安装 haxeui-flixel 后端：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib install flixel
haxelib install haxeui-core
haxelib install haxeui-flixel
haxelib run lime setup flixel</code></pre><p>使用下面的命令在当前目录下创建一个 haxeui-flixel 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core create flixel</code></pre><p>另外，使用 haxeui-flixel 后端的项目也无法使用 <code>haxelib run haxeui-core build flixel windows</code> 之类的命令进行构建，提示如下错误：</p><pre><code class=language-text> ERROR: no build found
 Invalid field access : execute</code></pre><p>Flixel 底层基于 Lime，因此可以用如下命令构建：</p><pre><span class=code-lang>shell</span><code class=language-shell>lime build windows</code></pre><p>需要注意的是，Flixel 和 OpenFL 一样使用 <em>Project.xml</em> 作为项目配置文件，因此同一个项目需要同时使用 OpenFL 和 Flixel 后端会比较麻烦。</p><p>Flixel 主要用于开发像素类游戏，因此内置的是一种像素风的字体，不太适合作为通用应用的后端。且和 OpenFL 后端有同样的问题——默认不支持渲染非英文字符。</p><h2 id=haxeui-heaps>haxeui-heaps</h2><p>haxeui-heaps 是 HaxeUI 的 <a href=https://heaps.io/ target=_blank rel=noopener>Heaps</a> 后端。</p><p>Heaps 也是一款游戏引擎框架，不过它不支持转译成 C++ 编译。只能编译为 HTML 5 或者 HashLink 虚拟机字节码。该后端的实用性不大，因此本文不做测试。</p><h2 id=haxeui-raylib>haxeui-raylib</h2><p>haxeui-raylib 是 HaxeUI 的 <a href=https://www.raylib.com/ target=_blank rel=noopener>Raylib</a> 后端。</p><p>特别地，使用命令 <code>haxelib run haxeui-core install raylib</code> 无法安装 haxeui-raylib，而使用 <code>haxelib install haxeui-raylib</code> 会提示如下错误：</p><pre><code class=language-text>Error: Failed with error: No such Project : haxeui-raylib</code></pre><p>另外，使用 haxeui-raylib 后端还需要依赖 <a href=https://lib.haxe.org/p/raylib-haxe/ target=_blank rel=noopener>raylib-haxe</a>。但是通过 haxelib 安装的 raylib-haxe 版本太旧，无法正确编译。我们只能从 GitHub 安装最新的版本：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib git raylib-haxe https://github.com/haxeui/raylib-haxe
haxelib git haxeui-raylib https://github.com/haxeui/haxeui-raylib</code></pre><div class=note><div class=note-header><span class=note-title>吐槽</span></div><div class=note-content><p>不得不说，这个 HaxeUI 还真是个半成品呀~</p></div></div><p>使用下面的命令在当前目录下创建一个 haxeui-raylib 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxelib run haxeui-core create raylib</code></pre><p>使用如下命令编译 haxeui-raylib 项目：</p><pre><span class=code-lang>shell</span><code class=language-shell>haxe raylib.hxml</code></pre><p>和 Flixel 相似，Raylib 后端默认也是用像素风格的字体，且默认不支持渲染非英文字符。</p><h2 id=总结>总结</h2><p>HaxeUI 内置的控件十分丰富，在使用图形引擎后端的情况下，基本能保持不同平台下界面布局和样式的一致性。但是各种小问题也很多，特别是对 i18n 的支持有很多问题。</p><p>下面列举了一些主要问题：</p><ul><li>有些后端不可用，或者是我打开的方法不正确</li><li>haxeui-nme 和 haxeui-openfl 都是通过 SDL 图形引擎绘制控件，这会引起一些兼容性问题：<ul><li>NME 默认能够支持中文，但 OpenFL 需要额外的代码才能显示中文</li><li>两者编译的 Linux 版皆无法在 WSL 2 内置的 MSRDC 中正常渲染，必须使用 X11 Server 才行</li></ul></li><li>只有 haxeui-hxwidgets 后端能够在中文环境下正常工作（虽然也有 UTF-8 乱码问题需要另外解决），其他后端都有中文显示或者输入的问题未能解决</li><li>haxeui-hxwidgets 使用原生控件，对于非标准布局程序运行时会报错：
<img src=/posts/cross-platform-GUI-framework-HaxeUI-trials/wxwidget-alert.png alt=wxwidget-alert></li></ul><p>对于桌面应用，在这些后端里唯二可用的便是 OpenFL 和 wxWidgets，其他后端可以不用考虑。</p><hr><h2 id=浅析-openfl-中文显示问题>浅析 OpenFL 中文显示问题</h2><p>后续稍微分析了一下 OpenFL 的源代码，大致弄清楚 OpenFL 为何默认无法显示中文了。</p><p>查看 <a href=https://github.com/openfl/openfl/blob/c114edd36b6e8118533b664001d68b89eda3833b/src/openfl/text/_internal/TextEngine.hx#L300 target=_blank rel=noopener>src/openfl/text/_internal/TextEngine.hx</a> 中的 <code>getDefaultFont()</code> 函数实现。OpenFL 内置了三组字体，分别是 <code>_sans</code>, <code>_serif</code> 和 <code>_typewriter</code> 。这三组字体在 Windows 中分别对应了 <code>Arial</code>, <code>Times New Roman</code> 和 <code>Courier New</code> 。这三组字体都是英文字体，不包含中文字形。而 haxeui-openfl 组件默认使用 <code>_sans</code> 字体，因此无法渲染中文字符。</p><figure class=code><pre><span class=code-lang>haxe</span><code data-ln-selected data-ln-start-from=320 data-ln=true class=language-haxe>#if windows
__defaultFonts.set(&#34;_sans&#34;,
    new DefaultFontSet(findFont(systemFontDirectory &#43; &#34;/arial.ttf&#34;), findFont(systemFontDirectory &#43; &#34;/arialbd.ttf&#34;),
        findFont(systemFontDirectory &#43; &#34;/ariali.ttf&#34;), findFont(systemFontDirectory &#43; &#34;/arialbi.ttf&#34;)));

__defaultFonts.set(&#34;_serif&#34;,
    new DefaultFontSet(findFont(systemFontDirectory &#43; &#34;/times.ttf&#34;), findFont(systemFontDirectory &#43; &#34;/timesbd.ttf&#34;),
        findFont(systemFontDirectory &#43; &#34;/timesi.ttf&#34;), findFont(systemFontDirectory &#43; &#34;/timesbi.ttf&#34;)));

__defaultFonts.set(&#34;_typewriter&#34;,
    new DefaultFontSet(findFont(systemFontDirectory &#43; &#34;/cour.ttf&#34;), findFont(systemFontDirectory &#43; &#34;/courbd.ttf&#34;),
        findFont(systemFontDirectory &#43; &#34;/couri.ttf&#34;), findFont(systemFontDirectory &#43; &#34;/courbi.ttf&#34;)));</code></pre><figcaption>TextEngine.hx</figcaption></figure><p>如果 OpenFL 要使用中文字体，可以在代码中添加：</p><pre><span class=code-lang>haxe</span><code class=language-haxe>openfl.text.Font.registerFont(openfl.text.Font.fromFile(lime.system.System.fontsDirectory &#43; &#34;/simhei.ttf&#34;));</code></pre><p>然后还要在视图中显式定义字体：</p><pre><span class=code-lang>html</span><code class=language-html>&lt;style&gt;
* {
    font-name: SimHei;
}
&lt;/style&gt;</code></pre><p>暂时没有通用的解决方案，针对不同的语言环境，必须显式定义不同的字体。</p><p>而 NME 后端之所以能正常显示中文是因为 NME 使用了本地 C++ 代码，直接调用 Windows 字体渲染接口，实现了 Fallback Font 的特性。</p></div><div class=taxonomy data-pagefind-ignore><div class=taxonomy-tags><ul class=tags><li>#<a data-pagefind-filter=标签 href=/tags/Haxe/>Haxe</a></li></ul></div></div><div class=pagination data-pagefind-ignore><a href=/posts/bugfix-openfl-textfield-IME-candidate-pane-invisible-issue/ class="left arrow">上一篇：<br>修复 OpenFL 的 TextField 不显示输入法候选词列表的问题</a>
<a href=/posts/running-lazarus-ide-in-wsl/ class="right arrow">下一篇：<br>在 WSL 中运行 Lazarus IDE</a>
<a href=# class=top>返回顶部</a></div></main><script src=/js/page.js></script><script src=/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/highlight.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/scala.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/nim.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/powershell.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/nginx.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/delphi.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/dos.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/haxe.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://unpkg.com/highlightjs-svelte/dist/svelte.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://unpkg.com/highlightjs-zig/dist/zig.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://unpkg.com/highlightjs-redbol/dist/redbol.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=/js/code.js></script><script>hljs.highlightAll(),hljs.initLineNumbersOnLoad(),hljs.initSelectLines()</script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js crossorigin=anonymous referrerpolicy=no-referrer onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"\\[",right:"\\]",display:!0},{left:"$$",right:"$$",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><footer><span>&copy; <time datetime="2025-05-15 06:50:35.577715374 +0000 UTC m=+1.254531225">2025</time> fournoas.com. Powered by <a href=https://gohugo.io/>Hugo</a> v0.147.3.</span></footer></body></html>