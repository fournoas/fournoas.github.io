<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Nim 语言的动态分发机制 &middot; 白汤四物</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/rainbow.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/scala.min.js crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/nim.min.js crossorigin=anonymous></script><script>hljs.initHighlightingOnLoad();</script><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href rel=alternate type=application/rss+xml title=白汤四物><script async src="https://www.googletagmanager.com/gtag/js?id=UA-153840298-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-153840298-1');</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><main><div class=post><h1 class=post-title>Nim 语言的动态分发机制</h1><div class=post-line></div><div class=post-info><span>作者</span>
Fournoas
<span>于&nbsp;</span><time datetime="2021-03-15 00:00:00 &#43;0000 UTC">2021年3月15日</time>
<span>发布在</span><ul class=categories><li><a href=https://www.fournoas.com/categories/coding/>Coding</a></li></ul></div><p><a href=https://nim-lang.org/ target=_blank>Nim</a> 是一款 Python 风格的静态类型语言。但事实上，除了缩进语法外，Nim 和 Python 并没有太多相似之处。相对于 Python，Nim 更多地吸收了 Ada 和 Lisp 等语言的特性。</p><p>Nim 编译器通过生成 C 或 Obj-C 中间代码的方式来进行本地编译，所以需要依赖一套外部编译器。Nim 也可以生成 Javascript 代码。此外，还有以脚本方式运行的 <a href=https://nim-lang.org/docs/nims.html target=_blank>NimScript</a>。</p><p>OOP 的一个特性就是支持多态，而<strong>动态分发</strong>（Dynamic Dispatch）就是实现多态的基础。在讲解 Nim 的动态分发实现前，先讲一下其他语言是如何实现的。</p><h2 id=c-虚函数>C++ 虚函数</h2><p>为了实现动态分发，C++ 必须将方法声明为 virtual。编译器会为每个类创建一个虚函数表（vtable），并将其地址保存在每个创建的对象中。当调用虚函数时，需要通过虚函数表的偏移量来定位真正的方法入口。</p><h2 id=go-接口>Go 接口</h2><p>Go 语言通过接口实现动态分发。Go 的接口是隐式实现的，类型只需要实现接口的所有方法，而不需要像 Java 那样显示声明。编译器仅在类型转换、参数传递、函数返回等操作时，才进行类型检查。</p><p>Go 的接口（runtime.iface）类型包含两个指针，一个是指向数据结构的 data 指针，另一个指向 itab 结构，该结构保存了接口的方法入口表。这样做的优点是编译器实现更加简单，语法上也更灵活，缺点是接口类型占用了更多的空间。</p><h2 id=python-鸭子类型>Python 鸭子类型</h2><p>Python 等动态类型语言具有<a href=https://zh.wikipedia.org/zh-hans/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B target=_blank>鸭子类型</a>（Duck typing）的特性，对象方法都是动态分发，而无需显式声明。Python 将方法保存在一个 dict 散列表中，在运行时通过方法名称动态查找。如果在当前类中没有找到该方法，则通过 <a href=https://docs.python.org/zh-cn/3/glossary.html#term-method-resolution-order target=_blank>MRO</a> 依次向父类中查找。</p><p>显然，这种动态分发方式的开销是很高的。某些动态类型语言，例如 smalltalk 和 Javascript(V8) 会使用一种叫<a href=https://zh.wikipedia.org/zh-hans/%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98 target=_blank>内联缓存</a>（inline cache）的优化方式来提升运行效率。</p><h2 id=nim-动态分发>Nim 动态分发</h2><p>Nim 的数据和方法是分开定义的，这种风格有点类似 Julia 和 Common Lisp。用 <code>proc</code> 关键字定义的方法使用静态分发，如果要使用动态分发，则需要使用 <code>method</code> 关键字。</p><pre><code class=language-nim>type
  Foo = ref object of RootObj
  Bar = ref object of Foo

method dynamic_dispath(foo: Foo) {.base.} =
  echo &quot;foo&quot;

method dynamic_dispath(bar: Bar) =
  echo &quot;bar&quot;

proc static_dispath(foo: Foo) =
  echo &quot;foo&quot;

proc static_dispath(bar: Bar) =
  echo &quot;bar&quot;


var foo: Foo = new(Bar)
foo.static_dispath() # output: foo
foo.dynamic_dispath() # output: bar
</code></pre><p>同 Julia 和 Common Lisp 一样，Nim 也支持<a href=https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E5%88%86%E6%B4%BE target=_blank>多重分发</a>（Multiple dispatch）。</p><pre><code class=language-nim>type
  Thing = ref object of RootObj
  Unit = ref object of Thing
    x: int

method collide(a, b: Thing) {.inline.} =
  quit &quot;to override!&quot;

method collide(a: Thing, b: Unit) {.inline.} =
  echo &quot;1&quot;

method collide(a: Unit, b: Thing) {.inline.} =
  echo &quot;2&quot;

var a, b: Unit
new a
new b
collide(a, b) # output: 2
</code></pre><p><strong>注:</strong> 自 Nim 0.20 起，编译时需要使用参数 <code>--multimethods:on</code> 来启用多重分发支持。</p><p>此外，Nim 支持一种叫<a href=https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax target=_blank>统一函数调用语法</a>（Uniform Function Call Syntax）的风格：</p><pre><code class=language-nim>proc print(s: string) = echo s
proc print(s1: string, s2: string) = echo s1, s2

print(&quot;Hello World!&quot;)
print &quot;Hello World!&quot;
&quot;Hello World!&quot;.print()
&quot;Hello World!&quot;.print
&quot;Hello&quot;.print (&quot; World!&quot;)
&quot;Hello&quot;.print &quot; World!&quot;
</code></pre><p>Nim 的动态分发并没有通过虚函数表的方式来实现，而是在动态方法调用处内联展开一系列的 <code>if</code> 判断，根据调用对象的类型，最终选择不同的方法函数。</p><pre><code class=language-nim>type
  Base = ref object of RootObj
  Derived = ref object of Base

method dynamic_dispatch(foo: Base) = echo &quot;Base&quot;
method dynamic_dispatch(foo: Derived) = echo &quot;Derived&quot;

var foo: Base = new(Derived)

foo.dynamic_dispatch
</code></pre><p>生成的 C 代码如下：</p><pre><code class=language-c>/* section: NIM_merge_DATA */
STRING_LITERAL(TM__TK8P9bk048kbmFtnhzKkOjA_3, &quot;Base&quot;, 4);
static NIM_CONST tyArray__nHXaesL0DJZHyVS07ARPRA TM__TK8P9bk048kbmFtnhzKkOjA_2 = {((NimStringDesc*) &amp;TM__TK8P9bk048kbmFtnhzKkOjA_3)}
;
STRING_LITERAL(TM__TK8P9bk048kbmFtnhzKkOjA_5, &quot;Derived&quot;, 7);
static NIM_CONST tyArray__nHXaesL0DJZHyVS07ARPRA TM__TK8P9bk048kbmFtnhzKkOjA_4 = {((NimStringDesc*) &amp;TM__TK8P9bk048kbmFtnhzKkOjA_5)}
;

// ... ...

N_LIB_PRIVATE N_NIMCALL(void, dynamic_dispatch__c5r4zNoABA7a1469bvDyeFA)(tyObject_BasecolonObjectType___9c7UwwsDx9cls9baHKBs8Py0g* foo) {
	nimfr_(&quot;dynamic_dispatch&quot;, &quot;test.nim&quot;);
	nimln_(5, &quot;test.nim&quot;);
	echoBinSafe(TM__TK8P9bk048kbmFtnhzKkOjA_2, 1); // method dynamic_dispatch(foo: Base) = echo &quot;Base&quot;
	popFrame();
}
N_LIB_PRIVATE N_NIMCALL(void, dynamic_dispatch__NGJl71YhyrlEEKIVgc1qbA)(tyObject_DerivedcolonObjectType___KIiBF5jw56vc7JjtgVaRMg* foo) {
	nimfr_(&quot;dynamic_dispatch&quot;, &quot;test.nim&quot;);
	nimln_(6, &quot;test.nim&quot;);
	echoBinSafe(TM__TK8P9bk048kbmFtnhzKkOjA_4, 1); // method dynamic_dispatch(foo: Derived) = echo &quot;Derived&quot;
	popFrame();
}

// ... ...

N_LIB_PRIVATE N_NIMCALL(void, dynamic_dispatch__5KArHhtsF2JAL9bQSgyiLMA)(tyObject_BasecolonObjectType___9c7UwwsDx9cls9baHKBs8Py0g* foo) {
	nimfr_(&quot;dynamic_dispatch&quot;, &quot;test.nim&quot;);
	nimln_(84, &quot;\\.choosenim\\toolchains\\nim-1.4.4\\lib\\system\\ch&quot;
&quot;cks.nim&quot;);
	chckNilDisp(foo);
	nimln_(5, &quot;test.nim&quot;);
	{
		if (!((foo) &amp;&amp; ((*foo).Sup.m_type == (&amp;NTI__KIiBF5jw56vc7JjtgVaRMg_)))) goto LA3_;
		if (foo &amp;&amp; !isObj((*foo).Sup.m_type, (&amp;NTI__KIiBF5jw56vc7JjtgVaRMg_))){ raiseObjectConversionError(); }
		dynamic_dispatch__NGJl71YhyrlEEKIVgc1qbA(((tyObject_DerivedcolonObjectType___KIiBF5jw56vc7JjtgVaRMg*) (foo)));
	}
	goto LA1_;
	LA3_: ;
	{
		if (!((foo) &amp;&amp; (isObjWithCache((*foo).Sup.m_type, (&amp;NTI__9c7UwwsDx9cls9baHKBs8Py0g_), Nim_OfCheck_CACHE8)))) goto LA6_;
		dynamic_dispatch__c5r4zNoABA7a1469bvDyeFA(foo);
	}
	goto LA1_;
	LA6_: ;
	LA1_: ;
	popFrame();
}

// ... ...

N_LIB_PRIVATE N_NIMCALL(void, NimMainModule)(void) {
{
	TFrame FR_; FR_.len = 0;

	nimRegisterGlobalMarker(TM__TK8P9bk048kbmFtnhzKkOjA_6);

}/* preInitProc end */
{
	tyObject_DerivedcolonObjectType___KIiBF5jw56vc7JjtgVaRMg* T1_;
	nimfr_(&quot;test&quot;, &quot;test.nim&quot;);
	nimln_(8, &quot;test.nim&quot;);
	T1_ = (tyObject_DerivedcolonObjectType___KIiBF5jw56vc7JjtgVaRMg*)0;
	T1_ = new__hYny4BGj3LhiDCg0b9az6qQ();
	asgnRef((void**) (&amp;foo__arkQMChktByKQJ3cIC51Bg), &amp;T1_-&gt;Sup);
	nimln_(10, &quot;test.nim&quot;);
	dynamic_dispatch__5KArHhtsF2JAL9bQSgyiLMA(foo__arkQMChktByKQJ3cIC51Bg); // foo.dynamic_dispatch
	popFrame();
}
}
</code></pre><p>这种方式有个缺点：如果继承树很深，那么判断分支就会很长，调用的对象类型越是靠近根部，调用的开销越大。</p><pre><code class=language-nim>import times

type
  Base = ref object of RootObj
  Derived1 = ref object of Base
  Derived2 = ref object of Derived1
  Derived3 = ref object of Derived2
  Derived4 = ref object of Derived3
  Derived5 = ref object of Derived4
  Derived6 = ref object of Derived5
  Derived7 = ref object of Derived6
  Derived8 = ref object of Derived7
  Derived9 = ref object of Derived8
  Derived10 = ref object of Derived9

proc static_dispatch(foo: Base, count: int): int = count - 1
method dynamic_dispatch(foo: Base, count: int): int {.base.} = count - 1
method dynamic_dispatch(foo: Derived1, count: int): int = count + 1
method dynamic_dispatch(foo: Derived2, count: int): int = count + 2
method dynamic_dispatch(foo: Derived3, count: int): int = count + 3
method dynamic_dispatch(foo: Derived4, count: int): int = count + 4
method dynamic_dispatch(foo: Derived5, count: int): int = count + 5
method dynamic_dispatch(foo: Derived6, count: int): int = count + 6
method dynamic_dispatch(foo: Derived7, count: int): int = count + 7
method dynamic_dispatch(foo: Derived8, count: int): int = count + 8
method dynamic_dispatch(foo: Derived9, count: int): int = count + 9
method dynamic_dispatch(foo: Derived10, count: int): int = count + 10

var foo: Base = new(Base)
var start = cpuTime()
for i in 0..99999999:
    discard foo.dynamic_dispatch(i)
    
echo &quot;Time taken: &quot;, cpuTime() - start # Time taken: 1.342

foo = new(Derived10)
start = cpuTime()
for i in 0..99999999:
    discard foo.dynamic_dispatch(i)
    
echo &quot;Time taken: &quot;, cpuTime() - start # Time taken: 0.672

start = cpuTime()
for i in 0..99999999:
    discard foo.static_dispatch(i)
    
echo &quot;Time taken: &quot;, cpuTime() - start # Time taken: 0.055
</code></pre><p>调用 <code>Base</code> 的 <code>dynamic_dispatch</code> 方法所消耗时间是调用 <code>Derived10</code> 方法的两倍多。而 <code>proc</code> 关键字定义的静态分发耗时仅是动态分发的 1/10，之所以性能提升那么大，主要原因大概有两个。首先是 CPU 分支预测命中导致的性能提升，其次是编译器将函数调用优化为内联展开。</p></div><div class=taxonomy><div class=taxonomy-tags><ul class=tags><li>#<a href=https://www.fournoas.com/tags/Nim/>Nim</a></li></ul></div></div><div class=pagination><a href=/posts/Zettelkasten-method-and-bi-directional-links-is-not-necessary/ class="left arrow">上一篇：<br>不要迷信卢曼卡片盒方法和双向链笔记</a>
<a href=/posts/python-libraries-and-packages/ class="right arrow">下一篇：<br>Python 库资源收集</a>
<a href=# class=top>返回顶部</a></div></main><footer><span>&copy; <time datetime="2021-07-12 09:23:13.897474928 &#43;0000 UTC m=&#43;0.321126644">2021</time> fournoas.com. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/EmielH/tale-hugo>Tale</a> theme.</span></footer><script src=/js/main.js></script></body></html>