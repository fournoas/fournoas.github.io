<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 白汤四物</title><link>https://www.fournoas.com/tags/Python/</link><description>Recent content in Python on 白汤四物</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 31 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.fournoas.com/tags/Python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 的 signal 处理与 print() 的 reentrant call 运行时错误</title><link>https://www.fournoas.com/posts/python-signal-handlers-and-reentrant-call-runtime-error-of-print-function/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-signal-handlers-and-reentrant-call-runtime-error-of-print-function/</guid><description>在前文《为何 Windows 下无法用 Ctrl+C 终止 Python 进程》中，讲解了 Python 信号处理的基本原理。当时为了撰写文章而编写了一些测试代码，在运行某例测试代码时，发生了奇怪的 reentrant call 运行时错误。代码如下： import signal signal.signal(signal.SIGINT, lambda signum, frame: print(&#39;test&#39;)) while True: print(&#39;test&#39;) 在程序运行中按下 Ctrl+C，程序抛出 RuntimeError 异常。完整错误信息如下： Traceback (most recent call last): File &amp;quot;test.py&amp;quot;, line 4, in &amp;lt;module&amp;gt; while True: print(&#39;test&#39;) ^^^^^^^^^^^^^</description></item><item><title>Python 信号处理在不同平台上的差异</title><link>https://www.fournoas.com/posts/handling-signal-in-python-on-different-platforms/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/handling-signal-in-python-on-different-platforms/</guid><description>在前文《为何 Windows 下无法用 Ctrl+C 终止 Python 进程》中，虽然解释了产生该现象的原因，但却没有解释为何同样的代码在 Linux 下就可以用 Ctrl+C 来中止。究其原因，是由于在操作系统层面，Linux 和 Windows 对 SIGINT 的信号处理方式是完全不同的。 Python 的底层实现原理 Python 将操作系统或 C 标准库提供的信号处理器称作 Low-level signal handler，Pyt</description></item><item><title>为何 Windows 下无法用 Ctrl&#43;C 终止 Python 进程</title><link>https://www.fournoas.com/posts/why-does-ctrl-c-not-kill-python-process-in-windows-console/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/why-does-ctrl-c-not-kill-python-process-in-windows-console/</guid><description>在 Windows 命令行中按下 Ctrl+C 或者 Ctrl+Break 可以结束当前正在执行的命令。通常情况下，这个方法同样适用于 Python 的控制台进程。特别地，Python 内置了一个 KeyboardInterrupt 异常专门用于捕获按下 Ctrl+C 而触发的程序退出： try: while True: print(&#39;running...&#39;) except KeyboardInterrupt: print(&#39;keyboard interrupt received&#39;) # 退出前清理现场，释放资源 Python 触发 KeyboardInterrupt 异常的底层实现原理依赖于 signal 机制1。使用信号处理器也可以捕获</description></item><item><title>一道初中奥数题的蒙特卡洛解法</title><link>https://www.fournoas.com/posts/monte-carlo-simulation-of-a-middle-school-math-olympiad-problem/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/monte-carlo-simulation-of-a-middle-school-math-olympiad-problem/</guid><description>四只鸭子在一个圆形水池中随机游动。某一时刻，四只鸭子在同一半圆内的概率是多少？ 这个问题必须隐含一个前提：当水池被分为两半后，任意一只鸭子，要么属于这一边，要么属于另一边，不存在同时属于两边或不属于任何一边的情况。可以把鸭子视作质点，如果鸭子正好落在分割线上，则认为此鸭子属于顺时针</description></item><item><title>Python 的 MRO 和 C3 线性化</title><link>https://www.fournoas.com/posts/python-MRO-and-C3-linearization/</link><pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-MRO-and-C3-linearization/</guid><description>MRO，即 Method Resolution Order、方法解析顺序，是 Python 对象调用父类方法时的遍历顺序。由于 Python 支持多重继承，类的继承关系可视作一个有向无环图，方法解析顺序就相当于拓扑排序——将图中节点线性排列。自 Python 2.3 起，新式类通过 C3 线性化算法来计算 MRO。 之所以被称作 C3，是因为算法符合如下三个特性（Cons</description></item><item><title>Python 库资源收集</title><link>https://www.fournoas.com/posts/python-libraries-and-packages/</link><pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-libraries-and-packages/</guid><description>收集了流行的 Python 库和资源。会不定期更新</description></item><item><title>使用 Google Authenticator（谷歌身份验证器）</title><link>https://www.fournoas.com/posts/how-to-use-google-authenticator/</link><pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-use-google-authenticator/</guid><description>某些简单的业务场景需要一个管理后台，但是系统却没有复杂到需要引入一套用户体系。那么，谷歌身份验证器（Google Authenticator）可以作为管理后台的一种简单的身份认证方式。 Google Authenticator 是一款基于时间（TOTP）与哈希（HOTP）的一次性密码算法的两步验证软件令牌。其原理是通过密</description></item><item><title>Python Web 框架选型</title><link>https://www.fournoas.com/posts/choosing-a-python-web-framework/</link><pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/choosing-a-python-web-framework/</guid><description>Python Web 框架有如下几种部署方式： WSGI ASGI 独立部署 CGI/FastCGI WSGI是最常见的接口，由PEP333和PEP3333规范定义，获得了最广泛的支持。 WSGI接口的上游是HTTP Server，下游是WSGI应用，而提供WSGI服务的程序被称为WSGI容器。生产环境中常见的WSGI容器有Gunicorn、</description></item><item><title>编译安装 Python 时发生“Missing the OpenSSL lib”错误</title><link>https://www.fournoas.com/posts/the-python-ssl-extension-was-not-compiled-missing-the-OpenSSL-lib/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-python-ssl-extension-was-not-compiled-missing-the-OpenSSL-lib/</guid><description>使用pyenv在ubuntu18上安装多个python版本。按照文档，先安装编译依赖库： sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \ xz-utils tk-dev libffi-dev liblzma-dev python-openssl 使用 pyenv install -v x.x.x 命令来安装指定版本的python。在安装3.4及以下版本时会报错： ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib? 原因是ubuntu默认安装的libssl-d</description></item><item><title>编写兼容 python 2.7 和 3.5&#43; 的代码</title><link>https://www.fournoas.com/posts/writing-python-2.7-and-3.5-or-above-compatible-code/</link><pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/writing-python-2.7-and-3.5-or-above-compatible-code/</guid><description>编写新的代码最好不要再兼容 Python 2.6 及以下版本了，坑太多。兼容 2.7 就足够了。同样地，Python 3.5 及以下版本的坑也很多，Python 3 最好从 3.5 开始兼容。 导入模块 Python 3 默认绝对导入，Python 2 默认相对导入。所以代码第一行就应写上： from __future__ import absolute_import 异常处理 Python 2 和 3 异常处理语句有所差异，应使用新的异</description></item><item><title>Windows 下安装 Scrapy</title><link>https://www.fournoas.com/posts/how-to-install-Scrapy-in-Windows/</link><pubDate>Sat, 07 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-install-Scrapy-in-Windows/</guid><description>Scrapy 依赖的某些组件需要编译，所以需要安装 Visual C++ Build Tools（http://landinghub.visualstudio.com/visual-cpp-build-tools）。 另外可以在这里（https://www.lfd.uci.edu/~gohlke/pythonlibs/）找</description></item><item><title>PHP 和 Python 速查手册</title><link>https://www.fournoas.com/posts/php-and-python-quick-start-guide/</link><pubDate>Mon, 28 Dec 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/php-and-python-quick-start-guide/</guid><description>部署方式 PHP 的部署方式 PHP 程序有如下几种运行方式： CGI FastCGI ISAPI Extension Apache Mod 其中，CGI 和 FastCGI 以进程的方式运行，使用 nts（非线程安全）版本； ISAPI Extension 和 Apache Mod 以线程方式运行在宿主进程（IIS进程或Apache进程）内，使用 ts（线程安全）版本。 以上几种方式以 FastCGI 最为常见。PHP 5 自带的 php-cgi 可以直接运行 FastCGI 服务。</description></item></channel></rss>