<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 白汤四物</title><link>https://www.fournoas.com/tags/Python/</link><description>Recent content in Python on 白汤四物</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 10 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.fournoas.com/tags/Python/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Nuitka 将 Python 程序编译为 Windows 服务</title><link>https://www.fournoas.com/posts/compile-python-script-to-windows-service-using-nuitka/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/compile-python-script-to-windows-service-using-nuitka/</guid><description>2023-02-14 更新： 原来 Nuitka 商业版通过插件已经实现了编译 Windows service 的功能，但开源版本不提供此功能。掏钱是不可能掏钱的。本人 fork 了 Nuitka 项目，加入了编译 Windows service 的功能，只要在编译时加入 --windows-service 参数就将 Python 程序能构建成 Windows service 了： pip install nuitka-winsvc nuitka --onefile --windows-service --windows-service-name=myservice main.py 项目地址： https://github.com/tabris17/Nuitka-winsvc 在前文《Nuitka 编译时注入自定义 C 代码》中介绍了在 Nuitka 编译时注入自</description></item><item><title>Nuitka 编译时注入自定义 C 代码</title><link>https://www.fournoas.com/posts/nuitka-inject-custom-c-code-at-compile-time/</link><pubDate>Wed, 08 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/nuitka-inject-custom-c-code-at-compile-time/</guid><description>Nuitka 是一款用 Python 实现的 Python 编译器，可以生成独立的可执行文件。其原理是生成 C 代码，然后使用 Scons 调用 C 编译器进行编译构建。据说使用 Nuitka 编译后的程序性能比 CPython 更好，和传统的打包工具 py2exe 与 PyInstaller 相比， Nuitka 的优势相当明显。 Nuitka 的使用也十分简单。比如要将下面的 main.py 文件进行打包： # main.py print(&amp;#34;Nuitka&amp;#34;) 首先安装 Nuitka 和建议安装的三方库： pip</description></item><item><title>Python 3.5 之后的新特性</title><link>https://www.fournoas.com/posts/new-feature-after-python-3.5/</link><pubDate>Tue, 06 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/new-feature-after-python-3.5/</guid><description>Python 自 3.5 版本起，至当前 3.11 版本为止，变化相当大，引入了众多的新特性，了解这些变化对编写兼容性代码尤为重要。本文整理的一些版本的重要变化。 Python 3.5 此版本最早发布于 2015 年，最终版本为 3.5.10 ，发布于 2020 年。 [PEP 492] 使用 async/await 语法实现协程 见 PEP 492 。 此特性是 3.5 版本最重大的变化。自此，Python 支持 async 和 await 语法，用于</description></item><item><title>快速了解 SOCKS5 代理协议</title><link>https://www.fournoas.com/posts/socks5-proxy-protocol-quick-start/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/socks5-proxy-protocol-quick-start/</guid><description>SOCKS5 是最常见的代理服务协议，服务通常使用 1080 端口，支持代理 TCP/UDP 网络协议。协议由 RFC 1928 定义，也可以阅读非官方翻译的中文版。本文主要用于快速入门，省略了协议中不常用的部分。文中提供了协议的部分 Python 代码实现。 sequenceDiagram title 建立 SOCKS5 代理的流程 participant client as 客户端 participant proxy as SOCKS5 代理 participant dest as 目标服务器 client->>proxy: 连接代理服务器 proxy-->>client: 连接成功 client->>proxy:</description></item><item><title>asyncio.DatagramProtocol 收到错误后停止响应</title><link>https://www.fournoas.com/posts/asyncio.DatagramProtocol-stop-responding-when-an-error-is-received/</link><pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/asyncio.DatagramProtocol-stop-responding-when-an-error-is-received/</guid><description>Python 官方文档提供了一个使用 asyncio 创建 UDP Echo Server 的示例，代码如下： import asyncio class EchoServerProtocol: def connection_made(self, transport): self.transport = transport def datagram_received(self, data, addr): message = data.decode() print(&amp;#39;Received %r from %s&amp;#39; % (message, addr)) print(&amp;#39;Send %r to %s&amp;#39; % (message, addr)) self.transport.sendto(data, addr) async def main(): print(&amp;#34;Starting UDP server&amp;#34;) # Get a reference to the event loop as we plan to use # low-level APIs. loop = asyncio.get_running_loop() # One protocol instance will be created to serve all # client requests. transport, protocol = await loop.create_datagram_endpoint( lambda: EchoServerProtocol(), local_addr=(&amp;#39;127.0.0.1&amp;#39;, 9999)) try: await asyncio.sleep(3600) # Serve for 1 hour. finally: transport.close() asyncio.run(main()) 然而，一旦收到运行时错误，该 UDP Server 便会失去响应</description></item><item><title>Python asyncio 模块实现简单异步 https 请求</title><link>https://www.fournoas.com/posts/python-asyncio-module-implements-simple-asynchronous-https-requests/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-asyncio-module-implements-simple-asynchronous-https-requests/</guid><description>网上关于 asyncio 实现异步 https 请求的代码几乎都是基于Python 第三方库 aiohttp 的，而我仅需要一个无第三方依赖的、能一键运行的简单 Python 脚本。翻了翻官方文档，也没有什么值得参考的 sample 代码。无奈只能自己动手撸一个。 以下示例代码的作用是，请求百度首页，并将响应打印出来。支持 Python 3.7 及以上的版本。 版本一 使用 loop.create_connection() 从</description></item><item><title>Python 信号处理在不同平台上的差异</title><link>https://www.fournoas.com/posts/handling-signal-in-python-on-different-platforms/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/handling-signal-in-python-on-different-platforms/</guid><description>在前文《为何 Windows 下无法用 Ctrl+C 终止 Python 进程》中，虽然解释了产生该现象的原因，但却没有解释为何同样的代码在 Linux 下就可以用 Ctrl+C 来中止。究其原因，是由于在操作系统层面，Linux 和 Windows 对 SIGINT 的信号处理方式不同所导致的。 Python 的底层实现原理 Python 将操作系统或 C 标准库提供的信号处理器称作 Low-level signal handler，Pyt</description></item><item><title>Python 的 signal 处理与 print() 的 reentrant call 运行时错误</title><link>https://www.fournoas.com/posts/python-signal-handlers-and-reentrant-call-runtime-error-of-print-function/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-signal-handlers-and-reentrant-call-runtime-error-of-print-function/</guid><description>在前文《为何 Windows 下无法用 Ctrl+C 终止 Python 进程》中，讲解了 Python 信号处理的基本原理。当时为了撰写文章而编写了一些测试代码，在运行某例测试代码时，发生了奇怪的 reentrant call 运行时错误。代码如下： import signal signal.signal(signal.SIGINT, lambda signum, frame: print(&amp;#39;test&amp;#39;)) while True: print(&amp;#39;test&amp;#39;) 在程序运行中按下 Ctrl+C，程序抛出 RuntimeError 异常。完整错误信息如下： Traceback (most recent call last): File &amp;#34;test.py&amp;#34;, line 4, in &amp;lt;module&amp;gt; while True: print(&amp;#39;test&amp;#39;) ^^^^^^^^^^^^^</description></item><item><title>为何 Windows 下无法用 Ctrl+C 终止 Python 进程</title><link>https://www.fournoas.com/posts/why-does-ctrl-c-not-kill-python-process-in-windows-console/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/why-does-ctrl-c-not-kill-python-process-in-windows-console/</guid><description>在 Windows 命令行中按下 Ctrl+C 或者 Ctrl+Break 可以结束当前正在执行的命令。通常情况下，这个方法同样适用于 Python 的控制台进程。特别地，Python 内置了一个 KeyboardInterrupt 异常专门用于捕获按下 Ctrl+C 而触发的程序退出： try: while True: print(&amp;#39;running...&amp;#39;) except KeyboardInterrupt: print(&amp;#39;keyboard interrupt received&amp;#39;) # 退出前清理现场，释放资源 Python 触发 KeyboardInterrupt 异常的底层实现原理依赖于 signal 机制1。使用信号处理器也可以捕获</description></item><item><title>一道初中奥数题的蒙特卡洛解法</title><link>https://www.fournoas.com/posts/monte-carlo-simulation-of-a-middle-school-math-olympiad-problem/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/monte-carlo-simulation-of-a-middle-school-math-olympiad-problem/</guid><description>四只鸭子在一个圆形水池中随机游动。某一时刻，四只鸭子在同一半圆内的概率是多少？ 这个问题必须隐含一个前提：当水池被分为两半后，任意一只鸭子，要么属于这一边，要么属于另一边，不存在同时属于两边或不属于任何一边的情况。可以把鸭子视作质点，如果鸭子正好落在分割线上，则认为此鸭子属于顺时针</description></item><item><title>Python 的 MRO 和 C3 线性化</title><link>https://www.fournoas.com/posts/python-MRO-and-C3-linearization/</link><pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-MRO-and-C3-linearization/</guid><description>MRO，即 Method Resolution Order、方法解析顺序，是 Python 对象调用父类方法时的遍历顺序。由于 Python 支持多重继承，类的继承关系可视作一个有向无环图，方法解析顺序就相当于拓扑排序——将图中节点线性排列。自 Python 2.3 起，新式类通过 C3 线性化算法来计算 MRO。 之所以被称作 C3，是因为算法符合如下三个特性（Cons</description></item><item><title>Python 库资源收集</title><link>https://www.fournoas.com/posts/python-libraries-and-packages/</link><pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/python-libraries-and-packages/</guid><description>收集了流行的 Python 库和资源。会不定期更新</description></item><item><title>使用 Google Authenticator（谷歌身份验证器）</title><link>https://www.fournoas.com/posts/how-to-use-google-authenticator/</link><pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-use-google-authenticator/</guid><description>某些简单的业务场景需要一个管理后台，但是系统却没有复杂到需要引入一套用户体系。那么，谷歌身份验证器（Google Authenticator）可以作为管理后台的一种简单的身份认证方式。 Google Authenticator 是一款基于时间（TOTP）与哈希（HOTP）的一次性密码算法的两步验证软件令牌。其原理是通过密</description></item><item><title>Python Web 框架选型</title><link>https://www.fournoas.com/posts/choosing-a-python-web-framework/</link><pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/choosing-a-python-web-framework/</guid><description>Python Web 框架有如下几种部署方式： WSGI ASGI 独立部署 CGI/FastCGI WSGI是最常见的接口，由PEP333和PEP3333规范定义，获得了最广泛的支持。 WSGI接口的上游是HTTP Server，下游是WSGI应用，而提供WSGI服务的程序被称为WSGI容器。生产环境中常见的WSGI容器有Gunicorn、</description></item><item><title>编译安装 Python 时发生“Missing the OpenSSL lib”错误</title><link>https://www.fournoas.com/posts/the-python-ssl-extension-was-not-compiled-missing-the-OpenSSL-lib/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-python-ssl-extension-was-not-compiled-missing-the-OpenSSL-lib/</guid><description>使用pyenv在ubuntu18上安装多个python版本。按照文档，先安装编译依赖库： sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \ xz-utils tk-dev libffi-dev liblzma-dev python-openssl 使用 pyenv install -v x.x.x 命令来安装指定版本的python。在安装3.4及以下版本时会报错： ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib? 原因是ubuntu默认安装的libssl-d</description></item><item><title>编写兼容 python 2.7 和 3.5+ 的代码</title><link>https://www.fournoas.com/posts/writing-python-2.7-and-3.5-or-above-compatible-code/</link><pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/writing-python-2.7-and-3.5-or-above-compatible-code/</guid><description>编写新的代码最好不要再兼容 Python 2.6 及以下版本了，坑太多。兼容 2.7 就足够了。同样地，Python 3.5 及以下版本的坑也很多，Python 3 最好从 3.5 开始兼容。 导入模块 Python 3 默认绝对导入，Python 2 默认相对导入。所以代码第一行就应写上： from __future__ import absolute_import 异常处理 Python 2 和 3 异常处理语句有所差异，应使用新的异</description></item><item><title>Windows 下安装 Scrapy</title><link>https://www.fournoas.com/posts/how-to-install-Scrapy-in-Windows/</link><pubDate>Sat, 07 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-install-Scrapy-in-Windows/</guid><description>Scrapy 依赖的某些组件需要编译，所以需要安装 Visual C++ Build Tools（http://landinghub.visualstudio.com/visual-cpp-build-tools）。 另外可以在这里（https://www.lfd.uci.edu/~gohlke/pythonlibs/）找</description></item><item><title>PHP 和 Python 速查手册</title><link>https://www.fournoas.com/posts/php-and-python-quick-start-guide/</link><pubDate>Mon, 28 Dec 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/php-and-python-quick-start-guide/</guid><description>部署方式 PHP 的部署方式 PHP 程序有如下几种运行方式： CGI FastCGI ISAPI Extension Apache Mod 其中，CGI 和 FastCGI 以进程的方式运行，使用 nts（非线程安全）版本； ISAPI Extension 和 Apache Mod 以线程方式运行在宿主进程（IIS进程或Apache进程）内，使用 ts（线程安全）版本。 以上几种方式以 FastCGI 最为常见。PHP 5 自带的 php-cgi 可以直接运行 FastCGI 服务。</description></item></channel></rss>