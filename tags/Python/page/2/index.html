<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Python &#183; 白汤四物</title>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js crossorigin=anonymous></script><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/rainbow.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href rel=alternate type=application/rss+xml title=白汤四物><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-3GNL63B62Q"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3GNL63B62Q")</script></head><body><nav class=nav><div class=nav-container><h1 class=nav-title><a href=/><img src=/logo.png alt=白汤四物></a></h1><ul><li><a href=/posts/><span>文章</span></a></li><li><a href=/moments/><span>动态</span></a></li><li><a href=/categories/><span>分类</span></a></li><li><a href=/tags/><span>标签</span></a></li><li><a href=/search/><span>搜索</span></a></li><li><a href=/about/><span>关于</span></a></li></ul></div></nav><div class=banner><main><ul class=breadcrumb><li><a href=../>标签</a></li><li class=active>Python</li></ul></main></div><main class=taxon><div class="catalogue taxonomy"><div class=catalogue-item><time datetime="2022-10-31 00:00:00 +0000 UTC" class=catalogue-time>2022年10月31日</time>
<a href=https://www.fournoas.com/posts/python-signal-handlers-and-reentrant-call-runtime-error-of-print-function/ class=catalogue-title>Python 的 signal 处理与 print() 的 reentrant call 运行时错误</a><div class=catalogue-line></div><p><p>在前文《<a href=../why-does-ctrl-c-not-kill-python-process-in-windows-console/>为何 Windows 下无法用 Ctrl+C 终止 Python 进程</a>》中，讲解了 Python 信号处理的基本原理。当时为了撰写文章而编写了一些测试代码，在运行某例测试代码时，发生了奇怪的 reentrant call 运行时错误。代码如下：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>import signal

signal.signal(signal.SIGINT, lambda signum, frame: print(&#39;test&#39;))
while True: print(&#39;test&#39;)</code></pre><p>在程序运行中按下 Ctrl+C，程序抛出 RuntimeError 异常。完整错误信息如下：</p><pre><code class=language-text>Traceback (most recent call last):
  File &#34;test.py&#34;, line 4, in &lt;module&gt;
    while True: print(&#39;test&#39;)
                ^^^^^^^^^^^^^
  File &#34;test.py&#34;, line 3, in &lt;lambda&gt;
    signal.signal(signal.SIGINT, lambda signum, frame: print(&#39;test&#39;))
                                                       ^^^^^^^^^^^^^
RuntimeError: reentrant call inside &lt;_io.BufferedWriter name=&#39;&lt;stdout&gt;&#39;&gt;</code></pre><p>错误信息中所提到的 reentrant call 是一个计算机术语，它的意思是程序或者子例程（subroutine）在执行过程中被中断，此时再次调用该程序或者子例程。由于 Python 的信号处理器是运行在主线程中，所以不存在多线程冲突的可能。因此，猜想错误可能是由如下的代码引起的：</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2022-10-28 00:00:00 +0000 UTC" class=catalogue-time>2022年10月28日</time>
<a href=https://www.fournoas.com/posts/why-does-ctrl-c-not-kill-python-process-in-windows-console/ class=catalogue-title>为何 Windows 下无法用 Ctrl+C 终止 Python 进程</a><div class=catalogue-line></div><p><p>在 Windows 命令行中按下 <code>Ctrl+C</code> 或者 <code>Ctrl+Break</code> 可以结束当前正在执行的命令。通常情况下，这个方法同样适用于 Python 的控制台进程。特别地，Python 内置了一个 <code>KeyboardInterrupt</code> 异常专门用于捕获按下 <code>Ctrl+C</code> 而触发的程序退出：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>try:
    while True:
        print(&#39;running...&#39;)
except KeyboardInterrupt:
    print(&#39;keyboard interrupt received&#39;)
    # 退出前清理现场，释放资源</code></pre><p>Python 触发 <code>KeyboardInterrupt</code> 异常的底层实现原理依赖于 signal 机制<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。使用信号处理器也可以捕获按下 <code>Ctrl+C</code> 而触发的程序退出：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>import signal

def signal_handler(signum, frame):
    raise KeyboardInterrupt

signal.signal(signal.SIGINT, signal_handler)

try:
    while True:
        print(&#39;running...&#39;)
except KeyboardInterrupt:
    print(&#39;keyboard interrupt received&#39;)
    # 退出前清理现场，释放资源</code></pre><p>但是在某些情况下，Windows 的 Python 命令行程序无法用 <code>Ctrl+C</code> 或者 <code>Ctrl+Break</code> 终止。比如在 <a href=https://bugs.python.org/issue41437 target=_blank rel=noopener>issue 41437: SIGINT blocked by socket operations like recv on Windows</a> 中提到：在 Windows 中，当 <code>socket.recv()</code> 操作阻塞时，无法响应 <code>SIGINT</code>。类似的，当 <code>thread.join()</code> 操作阻塞时，也无法用 <code>Ctrl+C</code> 终止。例如下面代码在 Windows 下运行就无法使用 <code>Ctrl+C</code> 来退出：</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2022-10-20 00:00:00 +0000 UTC" class=catalogue-time>2022年10月20日</time>
<a href=https://www.fournoas.com/posts/monte-carlo-simulation-of-a-middle-school-math-olympiad-problem/ class=catalogue-title>一道初中奥数题的蒙特卡洛解法</a><div class=catalogue-line></div><p><figure><img src=/posts/monte-carlo-simulation-of-a-middle-school-math-olympiad-problem/problem.jpg alt=四只鸭子在一个圆形水池中随机游动。某一时刻，四只鸭子在同一半圆内的概率是多少？><figcaption><p>四只鸭子在一个圆形水池中随机游动。某一时刻，四只鸭子在同一半圆内的概率是多少？</p></figcaption></figure><p>这个问题必须隐含一个前提：当水池被分为两半后，任意一只鸭子，要么属于这一边，要么属于另一边，不存在同时属于两边或不属于任何一边的情况。可以把鸭子视作质点，如果鸭子正好落在分割线上，则认为此鸭子属于顺时针方向的一侧。</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2022-09-23 00:00:00 +0000 UTC" class=catalogue-time>2022年9月23日</time>
<a href=https://www.fournoas.com/posts/python-MRO-and-C3-linearization/ class=catalogue-title>Python 的 MRO 和 C3 线性化</a><div class=catalogue-line></div><p><p>MRO，即 Method Resolution Order、方法解析顺序，是 Python 对象调用父类方法时的遍历顺序。由于 Python 支持多重继承，类的继承关系可视作一个有向无环图，方法解析顺序就相当于拓扑排序——将图中节点线性排列。自 Python 2.3 起，新式类通过 <strong>C3 线性化</strong>算法来计算 MRO。</p><p>之所以被称作 C3，是因为算法符合如下三个特性（<strong>C</strong>onsistent with <strong>3</strong> properties）：</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2021-03-17 00:00:00 +0000 UTC" class=catalogue-time>2021年3月17日</time>
<a href=https://www.fournoas.com/posts/python-libraries-and-packages/ class=catalogue-title>Python 库资源收集</a><div class=catalogue-line></div><p>收集了流行的 Python 库和资源。会不定期更新&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2020-06-19 00:00:00 +0000 UTC" class=catalogue-time>2020年6月19日</time>
<a href=https://www.fournoas.com/posts/how-to-use-google-authenticator/ class=catalogue-title>使用 Google Authenticator（谷歌身份验证器）</a><div class=catalogue-line></div><p><p>某些简单的业务场景需要一个管理后台，但是系统却没有复杂到需要引入一套用户体系。那么，谷歌身份验证器（Google Authenticator）可以作为管理后台的一种简单的身份认证方式。</p><p>Google Authenticator 是一款基于时间（<a href=https://tools.ietf.org/html/rfc6238 target=_blank rel=noopener>TOTP</a>）与哈希（<a href=https://tools.ietf.org/html/rfc4226 target=_blank rel=noopener>HOTP</a>）的一次性密码算法的两步验证软件令牌。其原理是通过密钥与时间或者计数器序列计算出一个六到八位的一次性密码。</p><p>其中 HOTP 算法需要服务端维护一个额外的计数器，需要客户端和服务端的计数器保持同步才能验证一致。而 TOTP 算法只要保证服务端和客户端的时间同步即可验证一致（默认时间误差窗口是30秒）。</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2019-08-29 00:00:00 +0000 UTC" class=catalogue-time>2019年8月29日</time>
<a href=https://www.fournoas.com/posts/choosing-a-python-web-framework/ class=catalogue-title>Python Web 框架选型</a><div class=catalogue-line></div><p><p>Python Web 框架有如下几种部署方式：</p><ul><li>WSGI</li><li>ASGI</li><li>独立部署</li><li>CGI/FastCGI</li></ul><p>WSGI是最常见的接口，由PEP333和PEP3333规范定义，获得了最广泛的支持。</p><p>WSGI接口的上游是HTTP Server，下游是WSGI应用，而提供WSGI服务的程序被称为WSGI容器。生产环境中常见的WSGI容器有Gunicorn、uWSGI、Apache mod_wsgi等。另外，很多框架本身也提供了WSGI容器，比如：Gevent、Tornado、Twisted。其中，Gunicorn可以通过自定义worker_class搭载其他异步框架来提高性能，比如：Gevent、Tornado、Meinheld等，且容器中运行的也不一定是标准的WSGI应用，比如Gunicorn+Sanic。</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2019-01-19 00:00:00 +0000 UTC" class=catalogue-time>2019年1月19日</time>
<a href=https://www.fournoas.com/posts/the-python-ssl-extension-was-not-compiled-missing-the-OpenSSL-lib/ class=catalogue-title>编译安装 Python 时发生“Missing the OpenSSL lib”错误</a><div class=catalogue-line></div><p><p>使用pyenv在ubuntu18上安装多个python版本。按照文档，先安装编译依赖库：</p><pre><span class=code-lang>SHELL</span><code class=language-shell>sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \
libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \
xz-utils tk-dev libffi-dev liblzma-dev python-openssl</code></pre><p>使用 <code>pyenv install -v x.x.x</code> 命令来安装指定版本的python。在安装3.4及以下版本时会报错：</p><pre><code class=language-text>ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib?</code></pre><p>原因是ubuntu默认安装的libssl-dev版本是1.1，旧版本的python只支持1.0版本。</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2018-09-14 00:00:00 +0000 UTC" class=catalogue-time>2018年9月14日</time>
<a href=https://www.fournoas.com/posts/writing-python-2.7-and-3.5-or-above-compatible-code/ class=catalogue-title>编写兼容 python 2.7 和 3.5+ 的代码</a><div class=catalogue-line></div><p><p>编写新的代码最好不要再兼容 Python 2.6 及以下版本了，坑太多。兼容 2.7 就足够了。同样地，Python 3.5 及以下版本的坑也很多，Python 3 最好从 3.5 开始兼容。</p><h3 id=导入模块>导入模块</h3><p>Python 3 默认绝对导入，Python 2 默认相对导入。所以代码第一行就应写上：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>from __future__ import absolute_import</code></pre><h3 id=异常处理>异常处理</h3><p>Python 2 和 3 异常处理语句有所差异，应使用新的异常处理语句：</p><pre><span class=code-lang>PYTHON</span><code class=language-python>try:
    raise ValueError(&#39;value error&#39;)
except ValueError as e
    pass</code></pre><h3 id=显式继承新式类>显式继承新式类</h3><p>Python 3 默认使用新式类， 代码显式继承新式类实现兼容：</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/Python/>Python</a></li></ul></div><div class=catalogue-item><time datetime="2018-04-07 00:00:00 +0000 UTC" class=catalogue-time>2018年4月7日</time>
<a href=https://www.fournoas.com/posts/how-to-install-Scrapy-in-Windows/ class=catalogue-title>Windows 下安装 Scrapy</a><div class=catalogue-line></div><p><p>Scrapy 依赖的某些组件需要编译，所以需要安装 Visual C++ Build Tools（<a href=http://landinghub.visualstudio.com/visual-cpp-build-tools target=_blank rel=noopener>http://landinghub.visualstudio.com/visual-cpp-build-tools</a>）。</p><p>另外可以在这里（<a href=https://www.lfd.uci.edu/~gohlke/pythonlibs/ target=_blank rel=noopener>https://www.lfd.uci.edu/~gohlke/pythonlibs/</a>）找到第三方编译好的扩展包。</p><p>之前在别的电脑上安装都是成功的。然而今天在某电脑上按装到 Twisted 组件时就出错了。看错误提示是 Unicode 字符转换失败报错，而且好像和命令行的字符编码有关。尝试了 cmd 和 cmder 都不行。用 <code>chcp</code> 命令切换 charset 也不行。最后用 cygwin64 的命令行给安装成功了。</p>&mldr;&mldr;</p><ul class=catalogue-tags><li>#<a href=/tags/Python/>Python</a></li></ul></div></div><div class=pagination><a href=/tags/Python/ class="left arrow">上一页</a>
<a href=/tags/Python/page/3/ class="right arrow">下一页</a>
<span><sup>2</sup> &frasl; <sub>3</sub></span></div></main><script src=/js/main.js></script><footer><span>&copy; <time datetime="2024-09-19 06:37:13.666693507 +0000 UTC m=+1.293050982">2024</time> fournoas.com. Powered by <a href=https://gohugo.io>Hugo</a>.</span></footer></body></html>