<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PHP on 白汤四物</title><link>https://www.fournoas.com/tags/PHP/</link><description>Recent content in PHP on 白汤四物</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 07 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.fournoas.com/tags/PHP/index.xml" rel="self" type="application/rss+xml"/><item><title>特殊的服务器环境引发的 Laravel 框架异常</title><link>https://www.fournoas.com/posts/a-laravel-exception-caused-by-special-server-environment/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/a-laravel-exception-caused-by-special-server-environment/</guid><description>一个使用 Laravel 框架的项目，在某次更新生产环境代码后报了奇怪的错误。而代码在开发环境和测试环境运行都是正常的。由于无法接触到生产环境，只能通过 PHP 引擎的源代码来猜测导致错误的原因</description></item><item><title>解决 PHP Trait 不能定义常量及成员变量冲突的问题</title><link>https://www.fournoas.com/posts/how-to-resolve-php-traits-cannot-have-constants-and-property-conflict/</link><pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/how-to-resolve-php-traits-cannot-have-constants-and-property-conflict/</guid><description>PHP Trait 只能定义成员变量和方法，不能定义常量。如下代码会报错： // test.php trait UsageTrait { const THE_CONST_NAME = 1; } 错误消息为： Fatal error: Traits cannot have constants in test.php 想要在不同的类中共用一组常量，可以通过接口来解决： interface UsageConstantsInterface { const THE_CONST_NAME = __CLASS__; } trait UsageTrait { public function usageForBar() { echo UsageConstantsInterface::THE_CONST_NAME, PHP_EOL; } public function usageForFoo() { // 如果使用 UsageTrait 的类实现了 UsageConstantsInterface 接口， // 也可以使用 self::THE_CONST_NAME 来访问常量 echo self::THE_CONST_NAME, PHP_EOL; } } class Foo implements UsageConstantsInterface { use UsageTrait;</description></item><item><title>Laravel 强制 api 路由组返回 JSON</title><link>https://www.fournoas.com/posts/force-laravel-to-return-JSON-response-with-api-routes/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/force-laravel-to-return-JSON-response-with-api-routes/</guid><description>Laravel 的默认错误处理器通过 &lt;code>Illuminate\Http\Request&lt;/code> 的 &lt;code>expectsJson()&lt;/code> 方法来决定是否将错误信息渲染成 JSON 格式输出。这要求将请求头的 &lt;code>Accept&lt;/code> 字段设置为 &lt;code>application/json&lt;/code>。本文提供一种方法，在尽可能减少代码的情况下，强制让 api 路由组中的所有错误响应变成 JSON 格式，而不依赖于请求的 &lt;code>Accept&lt;/code> 头部</description></item><item><title>让 FastRoute 支持 URL 反向解析</title><link>https://www.fournoas.com/posts/make-FastRoute-support-url-reverse/</link><pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/make-FastRoute-support-url-reverse/</guid><description>&lt;a href="https://github.com/nikic/FastRoute">FastRoute&lt;/a> 是一款高性能路由组件，需要运行于 PHP 7.1 及以上版本。很多 PHP Web 框架都用它作为默认路由。然而这款路由组件不支持 URL 反向解析。&lt;a href="https://www.hyperf.io/">Hyperf&lt;/a> 框架也采用了这款路由组件，以下代码可以让 Hyperf 支持 URL 反向解析</description></item><item><title>Swoole 框架最佳实践</title><link>https://www.fournoas.com/posts/the-swoole-framework-best-practices/</link><pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/the-swoole-framework-best-practices/</guid><description>Swoole 是一种常驻内存进程 Reactor 模式的框架。 支持 Swoole 的 Web 框架： Laravel-Swoole Laravel-S Swoft Hyperf One EasySwoole 1 和 2 可以让 Swoole 支持 Laravel 框架；个人更倾向于 Hyperf；Swoft 很好，但也很重，如果要使用Swoft，不如考虑换个技术栈，比如 Java 或 Python。 优点 高性能 在 TechEmpower Framework Benchmarks 的测试中完胜 Node.js。 支持 Coroutine Coroutine 可以将步代码转换成异步</description></item><item><title>PHP 和 Python 速查手册</title><link>https://www.fournoas.com/posts/php-and-python-quick-start-guide/</link><pubDate>Mon, 28 Dec 2015 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/php-and-python-quick-start-guide/</guid><description>部署方式 PHP 的部署方式 PHP 程序有如下几种运行方式： CGI FastCGI ISAPI Extension Apache Mod 其中，CGI 和 FastCGI 以进程的方式运行，使用 nts（非线程安全）版本； ISAPI Extension 和 Apache Mod 以线程方式运行在宿主进程（IIS进程或Apache进程）内，使用 ts（线程安全）版本。 以上几种方式以 FastCGI 最为常见。PHP 5 自带的 php-cgi 可以直接运行 FastCGI 服务。</description></item><item><title>PHP 中的服务定位和依赖注入</title><link>https://www.fournoas.com/posts/service-locator-and-dependency-injection-in-php/</link><pubDate>Tue, 04 Jun 2013 00:00:00 +0000</pubDate><guid>https://www.fournoas.com/posts/service-locator-and-dependency-injection-in-php/</guid><description>尝试了很多PHP框架，有轻量级的，也有企业级的，发现解耦都做得很不好，自由度都很差。Zend framework2.0 做得还不错，就是封装太多，不够轻量。 一、创建对象 从最原始的new操作符，到abstract factory或builder等经典创建模式，都不能满足人民群众日益高涨的解耦需求。后来，MF创</description></item></channel></rss>